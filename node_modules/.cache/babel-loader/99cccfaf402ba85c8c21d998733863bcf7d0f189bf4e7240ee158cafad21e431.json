{"ast":null,"code":"var _jsxFileName = \"/home/johnlemon/portfolio/src/components/extra_functions/SphereAnimation.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect } from \"react\";\nimport * as THREE from \"three\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\n\n// CircleXZAnimation — 40 circunferencias ascendiendo con gradiente de color\n// - Se ha eliminado la función createCircleMaterial como pediste\n// - El color de cada circunferencia se calcula dinámicamente en función de\n//   su Y (altura) y su radio (sizeFactor). Las reglas son:\n//     * Las circunferencias grandes (cerca de y=50, radio ~= R) → color naranja\n//     * Las circunferencias pequeñas y altas → color azul\n//     * Las circunferencias pequeñas y bajas → color rojo\n// - La mezcla se hace interpolando los tres colores con pesos normalizados.\n// - Se mantiene el cálculo con tiempo absoluto (performance.now) para que\n//   funcione correctamente aunque la pestaña esté en background.\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function CircleXZAnimation() {\n  _s();\n  const mountRef = useRef(null);\n  useEffect(() => {\n    const mount = mountRef.current;\n    if (!mount) return;\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x071026);\n    const width = mount.clientWidth || window.innerWidth;\n    const height = mount.clientHeight || window.innerHeight;\n    const camera = new THREE.PerspectiveCamera(55, width / height, 0.1, 1000);\n    camera.position.set(0, 140, 260);\n    camera.lookAt(0, 50, 0);\n    const renderer = new THREE.WebGLRenderer({\n      antialias: true\n    });\n    renderer.setSize(width, height);\n    renderer.setPixelRatio(window.devicePixelRatio || 1);\n    mount.appendChild(renderer.domElement);\n    const amb = new THREE.AmbientLight(0xffffff, 0.55);\n    scene.add(amb);\n    const dir = new THREE.DirectionalLight(0xffffff, 0.4);\n    dir.position.set(50, 120, 80);\n    scene.add(dir);\n    const grid = new THREE.GridHelper(300, 30, 0x333333, 0x1a1a1a);\n    scene.add(grid);\n\n    // Parámetros\n    const R = 50; // radio de la \"esfera\"\n    const Y_MIN = 0;\n    const Y_MAX = 100;\n    const segments = 256;\n    const NUM_CIRCLES = 40; // 40 circunferencias\n\n    const circles = [];\n\n    // Colores base para el gradiente\n    const colorTop = new THREE.Color(0x4aa3ff); // azul (pequeñas y altas)\n    const colorMid = new THREE.Color(0xff9a3c); // naranja (grandes en y=50)\n    const colorBottom = new THREE.Color(0xff4b4b); // rojo (pequeñas y bajas)\n\n    function createCircle(i) {\n      const positions = new Float32Array((segments + 1) * 3);\n      const geometry = new THREE.BufferGeometry();\n      geometry.setAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\n      geometry.setDrawRange(0, segments + 1);\n      const material = new THREE.LineBasicMaterial({\n        color: colorMid.clone(),\n        transparent: true,\n        opacity: 0.75\n      });\n      const line = new THREE.Line(geometry, material);\n      scene.add(line);\n      return {\n        line,\n        geometry,\n        positions,\n        material\n      };\n    }\n    function updateCircleGeometry(circle, radius) {\n      const positions = circle.positions;\n      for (let i = 0; i <= segments; i++) {\n        const t = i / segments * Math.PI * 2;\n        const x = radius * Math.cos(t);\n        const z = radius * Math.sin(t);\n        const idx = i * 3;\n        positions[idx] = x;\n        positions[idx + 1] = 0;\n        positions[idx + 2] = z;\n      }\n      circle.geometry.attributes.position.needsUpdate = true;\n    }\n    function sphereRadiusAtY(yPos) {\n      const val = R * R - (yPos - R) * (yPos - R);\n      return val > 0 ? Math.sqrt(val) : 0;\n    }\n\n    // Creamos los círculos y sus offsets iniciales (en unidades Y)\n    const range = Y_MAX - Y_MIN;\n    for (let i = 0; i < NUM_CIRCLES; i++) {\n      const c = createCircle(i);\n      c.initialOffset = i / NUM_CIRCLES * range; // desfase en unidades Y\n      circles.push(c);\n    }\n\n    // Controles\n    const controls = new OrbitControls(camera, renderer.domElement);\n    controls.target.set(0, 50, 0);\n    controls.update();\n\n    // Tiempo absoluto para posiciones\n    const startTime = performance.now();\n    const speed = 6; // unidades Y por segundo\n\n    let rafId = null;\n    function computeColorForCircle(yPos, radius) {\n      // Normalizaciones\n      const sizeFactor = radius / R; // 0..1 (1 = máximo en y=50)\n      const yRel = (yPos - R) / R; // -1..1\n\n      const posTop = Math.max(0, yRel); // 0..1\n      const posBottom = Math.max(0, -yRel); // 0..1\n\n      // Peso medio depende del tamaño (cuanto más grande, más peso al naranja)\n      const wMid = sizeFactor;\n      const remaining = Math.max(0, 1 - wMid);\n\n      // Distribuimos el peso restante entre top y bottom según la posición relativa\n      const sumPos = posTop + posBottom + 1e-6; // evitar división por cero\n      const wTop = remaining * (posTop / sumPos);\n      const wBottom = remaining * (posBottom / sumPos);\n\n      // Normalizamos (por seguridad)\n      const total = wTop + wMid + wBottom || 1;\n      const nt = 1 / total;\n      const Wt = wTop * nt;\n      const Wm = wMid * nt;\n      const Wb = wBottom * nt;\n\n      // Mezcla lineal de los tres colores (componente a componente)\n      const r = Wt * colorTop.r + Wm * colorMid.r + Wb * colorBottom.r;\n      const g = Wt * colorTop.g + Wm * colorMid.g + Wb * colorBottom.g;\n      const b = Wt * colorTop.b + Wm * colorMid.b + Wb * colorBottom.b;\n      return {\n        r,\n        g,\n        b\n      };\n    }\n    function animate() {\n      const now = performance.now();\n      const elapsed = (now - startTime) / 1000; // segundos\n\n      for (let i = 0; i < NUM_CIRCLES; i++) {\n        const c = circles[i];\n        const posInRange = (c.initialOffset + elapsed * speed) % range;\n        const yPos = Y_MIN + posInRange;\n        const radius = sphereRadiusAtY(yPos);\n        updateCircleGeometry(c, radius);\n        c.line.position.y = yPos;\n\n        // Calculamos color y lo aplicamos al material\n        const col = computeColorForCircle(yPos, radius);\n        c.material.color.setRGB(col.r, col.g, col.b);\n      }\n      renderer.render(scene, camera);\n      rafId = requestAnimationFrame(animate);\n    }\n    rafId = requestAnimationFrame(animate);\n    function handleResize() {\n      const w = mount.clientWidth || window.innerWidth;\n      const h = mount.clientHeight || window.innerHeight;\n      camera.aspect = w / h;\n      camera.updateProjectionMatrix();\n      renderer.setSize(w, h);\n    }\n    window.addEventListener(\"resize\", handleResize);\n\n    // Limpieza al desmontar\n    return () => {\n      window.removeEventListener(\"resize\", handleResize);\n      if (rafId) cancelAnimationFrame(rafId);\n      circles.forEach(c => {\n        scene.remove(c.line);\n        c.geometry.dispose();\n        c.material.dispose();\n      });\n      controls.dispose();\n      renderer.dispose();\n      if (renderer.domElement && mount.contains(renderer.domElement)) {\n        mount.removeChild(renderer.domElement);\n      }\n    };\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: mountRef,\n    style: {\n      width: \"100vw\",\n      height: \"100vh\",\n      position: \"relative\"\n    },\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: \"absolute\",\n        left: 12,\n        top: 12,\n        padding: \"6px 10px\",\n        background: \"rgba(0,0,0,0.35)\",\n        color: \"#e6fff0\",\n        borderRadius: 8,\n        fontSize: 13\n      },\n      children: \"40 circunferencias ascendiendo \\u2014 gradiente seg\\xFAn tama\\xF1o y altura\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 204,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 203,\n    columnNumber: 5\n  }, this);\n}\n_s(CircleXZAnimation, \"V9/qkEdV8GfsDZk7lMTA1T8g5Ps=\");\n_c = CircleXZAnimation;\nvar _c;\n$RefreshReg$(_c, \"CircleXZAnimation\");","map":{"version":3,"names":["React","useRef","useEffect","THREE","OrbitControls","jsxDEV","_jsxDEV","CircleXZAnimation","_s","mountRef","mount","current","scene","Scene","background","Color","width","clientWidth","window","innerWidth","height","clientHeight","innerHeight","camera","PerspectiveCamera","position","set","lookAt","renderer","WebGLRenderer","antialias","setSize","setPixelRatio","devicePixelRatio","appendChild","domElement","amb","AmbientLight","add","dir","DirectionalLight","grid","GridHelper","R","Y_MIN","Y_MAX","segments","NUM_CIRCLES","circles","colorTop","colorMid","colorBottom","createCircle","i","positions","Float32Array","geometry","BufferGeometry","setAttribute","BufferAttribute","setDrawRange","material","LineBasicMaterial","color","clone","transparent","opacity","line","Line","updateCircleGeometry","circle","radius","t","Math","PI","x","cos","z","sin","idx","attributes","needsUpdate","sphereRadiusAtY","yPos","val","sqrt","range","c","initialOffset","push","controls","target","update","startTime","performance","now","speed","rafId","computeColorForCircle","sizeFactor","yRel","posTop","max","posBottom","wMid","remaining","sumPos","wTop","wBottom","total","nt","Wt","Wm","Wb","r","g","b","animate","elapsed","posInRange","y","col","setRGB","render","requestAnimationFrame","handleResize","w","h","aspect","updateProjectionMatrix","addEventListener","removeEventListener","cancelAnimationFrame","forEach","remove","dispose","contains","removeChild","ref","style","children","left","top","padding","borderRadius","fontSize","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/johnlemon/portfolio/src/components/extra_functions/SphereAnimation.jsx"],"sourcesContent":["import React, { useRef, useEffect } from \"react\";\nimport * as THREE from \"three\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\n\n// CircleXZAnimation — 40 circunferencias ascendiendo con gradiente de color\n// - Se ha eliminado la función createCircleMaterial como pediste\n// - El color de cada circunferencia se calcula dinámicamente en función de\n//   su Y (altura) y su radio (sizeFactor). Las reglas son:\n//     * Las circunferencias grandes (cerca de y=50, radio ~= R) → color naranja\n//     * Las circunferencias pequeñas y altas → color azul\n//     * Las circunferencias pequeñas y bajas → color rojo\n// - La mezcla se hace interpolando los tres colores con pesos normalizados.\n// - Se mantiene el cálculo con tiempo absoluto (performance.now) para que\n//   funcione correctamente aunque la pestaña esté en background.\n\nexport default function CircleXZAnimation() {\n  const mountRef = useRef(null);\n\n  useEffect(() => {\n    const mount = mountRef.current;\n    if (!mount) return;\n\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x071026);\n\n    const width = mount.clientWidth || window.innerWidth;\n    const height = mount.clientHeight || window.innerHeight;\n\n    const camera = new THREE.PerspectiveCamera(55, width / height, 0.1, 1000);\n    camera.position.set(0, 140, 260);\n    camera.lookAt(0, 50, 0);\n\n    const renderer = new THREE.WebGLRenderer({ antialias: true });\n    renderer.setSize(width, height);\n    renderer.setPixelRatio(window.devicePixelRatio || 1);\n    mount.appendChild(renderer.domElement);\n\n    const amb = new THREE.AmbientLight(0xffffff, 0.55);\n    scene.add(amb);\n    const dir = new THREE.DirectionalLight(0xffffff, 0.4);\n    dir.position.set(50, 120, 80);\n    scene.add(dir);\n\n    const grid = new THREE.GridHelper(300, 30, 0x333333, 0x1a1a1a);\n    scene.add(grid);\n\n    // Parámetros\n    const R = 50; // radio de la \"esfera\"\n    const Y_MIN = 0;\n    const Y_MAX = 100;\n    const segments = 256;\n    const NUM_CIRCLES = 40; // 40 circunferencias\n\n    const circles = [];\n\n    // Colores base para el gradiente\n    const colorTop = new THREE.Color(0x4aa3ff); // azul (pequeñas y altas)\n    const colorMid = new THREE.Color(0xff9a3c); // naranja (grandes en y=50)\n    const colorBottom = new THREE.Color(0xff4b4b); // rojo (pequeñas y bajas)\n\n    function createCircle(i) {\n      const positions = new Float32Array((segments + 1) * 3);\n      const geometry = new THREE.BufferGeometry();\n      geometry.setAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\n      geometry.setDrawRange(0, segments + 1);\n\n      const material = new THREE.LineBasicMaterial({\n        color: colorMid.clone(),\n        transparent: true,\n        opacity: 0.75,\n      });\n\n      const line = new THREE.Line(geometry, material);\n      scene.add(line);\n\n      return { line, geometry, positions, material };\n    }\n\n    function updateCircleGeometry(circle, radius) {\n      const positions = circle.positions;\n      for (let i = 0; i <= segments; i++) {\n        const t = (i / segments) * Math.PI * 2;\n        const x = radius * Math.cos(t);\n        const z = radius * Math.sin(t);\n        const idx = i * 3;\n        positions[idx] = x;\n        positions[idx + 1] = 0;\n        positions[idx + 2] = z;\n      }\n      circle.geometry.attributes.position.needsUpdate = true;\n    }\n\n    function sphereRadiusAtY(yPos) {\n      const val = R * R - (yPos - R) * (yPos - R);\n      return val > 0 ? Math.sqrt(val) : 0;\n    }\n\n    // Creamos los círculos y sus offsets iniciales (en unidades Y)\n    const range = Y_MAX - Y_MIN;\n    for (let i = 0; i < NUM_CIRCLES; i++) {\n      const c = createCircle(i);\n      c.initialOffset = (i / NUM_CIRCLES) * range; // desfase en unidades Y\n      circles.push(c);\n    }\n\n    // Controles\n    const controls = new OrbitControls(camera, renderer.domElement);\n    controls.target.set(0, 50, 0);\n    controls.update();\n\n    // Tiempo absoluto para posiciones\n    const startTime = performance.now();\n    const speed = 6; // unidades Y por segundo\n\n    let rafId = null;\n\n    function computeColorForCircle(yPos, radius) {\n      // Normalizaciones\n      const sizeFactor = radius / R; // 0..1 (1 = máximo en y=50)\n      const yRel = (yPos - R) / R; // -1..1\n\n      const posTop = Math.max(0, yRel); // 0..1\n      const posBottom = Math.max(0, -yRel); // 0..1\n\n      // Peso medio depende del tamaño (cuanto más grande, más peso al naranja)\n      const wMid = sizeFactor;\n      const remaining = Math.max(0, 1 - wMid);\n\n      // Distribuimos el peso restante entre top y bottom según la posición relativa\n      const sumPos = posTop + posBottom + 1e-6; // evitar división por cero\n      const wTop = remaining * (posTop / sumPos);\n      const wBottom = remaining * (posBottom / sumPos);\n\n      // Normalizamos (por seguridad)\n      const total = wTop + wMid + wBottom || 1;\n      const nt = 1 / total;\n      const Wt = wTop * nt;\n      const Wm = wMid * nt;\n      const Wb = wBottom * nt;\n\n      // Mezcla lineal de los tres colores (componente a componente)\n      const r = Wt * colorTop.r + Wm * colorMid.r + Wb * colorBottom.r;\n      const g = Wt * colorTop.g + Wm * colorMid.g + Wb * colorBottom.g;\n      const b = Wt * colorTop.b + Wm * colorMid.b + Wb * colorBottom.b;\n\n      return { r, g, b };\n    }\n\n    function animate() {\n      const now = performance.now();\n      const elapsed = (now - startTime) / 1000; // segundos\n\n      for (let i = 0; i < NUM_CIRCLES; i++) {\n        const c = circles[i];\n        const posInRange = (c.initialOffset + elapsed * speed) % range;\n        const yPos = Y_MIN + posInRange;\n\n        const radius = sphereRadiusAtY(yPos);\n        updateCircleGeometry(c, radius);\n        c.line.position.y = yPos;\n\n        // Calculamos color y lo aplicamos al material\n        const col = computeColorForCircle(yPos, radius);\n        c.material.color.setRGB(col.r, col.g, col.b);\n      }\n\n      renderer.render(scene, camera);\n      rafId = requestAnimationFrame(animate);\n    }\n\n    rafId = requestAnimationFrame(animate);\n\n    function handleResize() {\n      const w = mount.clientWidth || window.innerWidth;\n      const h = mount.clientHeight || window.innerHeight;\n      camera.aspect = w / h;\n      camera.updateProjectionMatrix();\n      renderer.setSize(w, h);\n    }\n\n    window.addEventListener(\"resize\", handleResize);\n\n    // Limpieza al desmontar\n    return () => {\n      window.removeEventListener(\"resize\", handleResize);\n      if (rafId) cancelAnimationFrame(rafId);\n\n      circles.forEach((c) => {\n        scene.remove(c.line);\n        c.geometry.dispose();\n        c.material.dispose();\n      });\n\n      controls.dispose();\n      renderer.dispose();\n      if (renderer.domElement && mount.contains(renderer.domElement)) {\n        mount.removeChild(renderer.domElement);\n      }\n    };\n  }, []);\n\n  return (\n    <div ref={mountRef} style={{ width: \"100vw\", height: \"100vh\", position: \"relative\" }}>\n      <div style={{ position: \"absolute\", left: 12, top: 12, padding: \"6px 10px\", background: \"rgba(0,0,0,0.35)\", color: \"#e6fff0\", borderRadius: 8, fontSize: 13 }}>\n        40 circunferencias ascendiendo — gradiente según tamaño y altura\n      </div>\n    </div>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}