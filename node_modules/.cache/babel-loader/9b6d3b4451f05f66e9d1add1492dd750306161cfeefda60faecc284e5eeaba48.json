{"ast":null,"code":"var _jsxFileName = \"/home/johnlemon/portfolio/src/components/extra_functions/SphereAnimation.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect } from \"react\";\nimport * as THREE from \"three\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction createEllipticalStackMesh(controlPoints, options = {}) {\n  var _options$height, _options$radialSegmen, _options$heightSegmen, _options$materialOpti;\n  const height = (_options$height = options.height) !== null && _options$height !== void 0 ? _options$height : 100;\n  const radialSegments = (_options$radialSegmen = options.radialSegments) !== null && _options$radialSegmen !== void 0 ? _options$radialSegmen : 64;\n  const heightSegments = (_options$heightSegmen = options.heightSegments) !== null && _options$heightSegmen !== void 0 ? _options$heightSegmen : 100;\n  const materialOptions = (_options$materialOpti = options.materialOptions) !== null && _options$materialOpti !== void 0 ? _options$materialOpti : {\n    side: THREE.DoubleSide,\n    transparent: true,\n    opacity: 0.9\n  };\n  controlPoints = controlPoints.slice().sort((a, b) => a.y - b.y);\n  function interpRadiiForY(y) {\n    if (y <= controlPoints[0].y) return {\n      rx: controlPoints[0].rx,\n      rz: controlPoints[0].rz\n    };\n    if (y >= controlPoints[controlPoints.length - 1].y) {\n      const p = controlPoints[controlPoints.length - 1];\n      return {\n        rx: p.rx,\n        rz: p.rz\n      };\n    }\n    for (let i = 0; i < controlPoints.length - 1; i++) {\n      const a = controlPoints[i];\n      const b = controlPoints[i + 1];\n      if (y >= a.y && y <= b.y) {\n        const t = (y - a.y) / (b.y - a.y);\n        return {\n          rx: a.rx + (b.rx - a.rx) * t,\n          rz: a.rz + (b.rz - a.rz) * t\n        };\n      }\n    }\n    return {\n      rx: 0,\n      rz: 0\n    };\n  }\n  const vertsCount = (heightSegments + 1) * (radialSegments + 1);\n  const positions = new Float32Array(vertsCount * 3);\n  const uvs = new Float32Array(vertsCount * 2);\n  const indices = [];\n  let idxPos = 0;\n  let idxUV = 0;\n  for (let iy = 0; iy <= heightSegments; iy++) {\n    const tY = iy / heightSegments;\n    const y = tY * height;\n    const {\n      rx,\n      rz\n    } = interpRadiiForY(y);\n    for (let ir = 0; ir <= radialSegments; ir++) {\n      const theta = ir / radialSegments * Math.PI * 2;\n      const x = rx * Math.cos(theta);\n      const z = rz * Math.sin(theta);\n      positions[idxPos++] = x;\n      positions[idxPos++] = y;\n      positions[idxPos++] = z;\n      uvs[idxUV++] = ir / radialSegments;\n      uvs[idxUV++] = tY;\n    }\n  }\n  for (let iy = 0; iy < heightSegments; iy++) {\n    for (let ir = 0; ir < radialSegments; ir++) {\n      const a = iy * (radialSegments + 1) + ir;\n      const b = a + (radialSegments + 1);\n      indices.push(a, b, a + 1);\n      indices.push(b, b + 1, a + 1);\n    }\n  }\n  const geometry = new THREE.BufferGeometry();\n  geometry.setAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\n  geometry.setAttribute(\"uv\", new THREE.BufferAttribute(uvs, 2));\n  geometry.setIndex(indices);\n  geometry.computeVertexNormals();\n  const mat = new THREE.MeshStandardMaterial(materialOptions);\n  return new THREE.Mesh(geometry, mat);\n}\n\n// puntos que pediste:\nconst controlPoints = [{\n  y: 0,\n  rx: 0,\n  rz: 0\n}, {\n  y: 10,\n  rx: 30,\n  rz: 30\n}, {\n  y: 20,\n  rx: 40,\n  rz: 40\n}, {\n  y: 50,\n  rx: 50,\n  rz: 50\n}, {\n  y: 80,\n  rx: 40,\n  rz: 40\n}, {\n  y: 90,\n  rx: 30,\n  rz: 30\n}, {\n  y: 100,\n  rx: 0,\n  rz: 0\n}];\nexport default function EllipticalShape() {\n  _s();\n  const mountRef = useRef();\n  useEffect(() => {\n    // escena\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(\"#000000\");\n    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);\n    camera.position.set(0, 80, 180);\n    const renderer = new THREE.WebGLRenderer({\n      antialias: true\n    });\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    mountRef.current.appendChild(renderer.domElement);\n\n    // luz\n    const light = new THREE.DirectionalLight(0xffffff, 1);\n    light.position.set(50, 100, 50);\n    scene.add(light);\n    const ambient = new THREE.AmbientLight(0x888888);\n    scene.add(ambient);\n\n    // ---- aquí se añade tu circunferencia 3D ----\n    const mesh = createEllipticalStackMesh(controlPoints, {\n      height: 100,\n      radialSegments: 64,\n      heightSegments: 200,\n      materialOptions: {\n        side: THREE.DoubleSide,\n        metalness: 0.1,\n        roughness: 0.6,\n        transparent: true,\n        opacity: 0.95,\n        color: 0x22ccff\n      }\n    });\n    mesh.position.set(0, 0, 0);\n    scene.add(mesh);\n\n    // animación\n    function animate() {\n      requestAnimationFrame(animate);\n      mesh.rotation.y += 0.003;\n      renderer.render(scene, camera);\n    }\n    animate();\n\n    // cleanup\n    return () => {\n      mountRef.current.removeChild(renderer.domElement);\n    };\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: mountRef,\n    style: {\n      width: \"100vw\",\n      height: \"100vh\"\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 150,\n    columnNumber: 10\n  }, this);\n}\n_s(EllipticalShape, \"V9/qkEdV8GfsDZk7lMTA1T8g5Ps=\");\n_c = EllipticalShape;\nvar _c;\n$RefreshReg$(_c, \"EllipticalShape\");","map":{"version":3,"names":["React","useRef","useEffect","THREE","jsxDEV","_jsxDEV","createEllipticalStackMesh","controlPoints","options","_options$height","_options$radialSegmen","_options$heightSegmen","_options$materialOpti","height","radialSegments","heightSegments","materialOptions","side","DoubleSide","transparent","opacity","slice","sort","a","b","y","interpRadiiForY","rx","rz","length","p","i","t","vertsCount","positions","Float32Array","uvs","indices","idxPos","idxUV","iy","tY","ir","theta","Math","PI","x","cos","z","sin","push","geometry","BufferGeometry","setAttribute","BufferAttribute","setIndex","computeVertexNormals","mat","MeshStandardMaterial","Mesh","EllipticalShape","_s","mountRef","scene","Scene","background","Color","camera","PerspectiveCamera","window","innerWidth","innerHeight","position","set","renderer","WebGLRenderer","antialias","setSize","current","appendChild","domElement","light","DirectionalLight","add","ambient","AmbientLight","mesh","metalness","roughness","color","animate","requestAnimationFrame","rotation","render","removeChild","ref","style","width","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/johnlemon/portfolio/src/components/extra_functions/SphereAnimation.jsx"],"sourcesContent":["import React, { useRef, useEffect } from \"react\";\nimport * as THREE from \"three\";\n\nfunction createEllipticalStackMesh(controlPoints, options = {}) {\n  const height = options.height ?? 100;\n  const radialSegments = options.radialSegments ?? 64;\n  const heightSegments = options.heightSegments ?? 100;\n  const materialOptions = options.materialOptions ?? { side: THREE.DoubleSide, transparent: true, opacity: 0.9 };\n\n  controlPoints = controlPoints.slice().sort((a, b) => a.y - b.y);\n\n  function interpRadiiForY(y) {\n    if (y <= controlPoints[0].y) return { rx: controlPoints[0].rx, rz: controlPoints[0].rz };\n    if (y >= controlPoints[controlPoints.length - 1].y) {\n      const p = controlPoints[controlPoints.length - 1];\n      return { rx: p.rx, rz: p.rz };\n    }\n    for (let i = 0; i < controlPoints.length - 1; i++) {\n      const a = controlPoints[i];\n      const b = controlPoints[i + 1];\n      if (y >= a.y && y <= b.y) {\n        const t = (y - a.y) / (b.y - a.y);\n        return {\n          rx: a.rx + (b.rx - a.rx) * t,\n          rz: a.rz + (b.rz - a.rz) * t,\n        };\n      }\n    }\n    return { rx: 0, rz: 0 };\n  }\n\n  const vertsCount = (heightSegments + 1) * (radialSegments + 1);\n  const positions = new Float32Array(vertsCount * 3);\n  const uvs = new Float32Array(vertsCount * 2);\n  const indices = [];\n\n  let idxPos = 0;\n  let idxUV = 0;\n\n  for (let iy = 0; iy <= heightSegments; iy++) {\n    const tY = iy / heightSegments;\n    const y = tY * height;\n    const { rx, rz } = interpRadiiForY(y);\n\n    for (let ir = 0; ir <= radialSegments; ir++) {\n      const theta = (ir / radialSegments) * Math.PI * 2;\n      const x = rx * Math.cos(theta);\n      const z = rz * Math.sin(theta);\n\n      positions[idxPos++] = x;\n      positions[idxPos++] = y;\n      positions[idxPos++] = z;\n\n      uvs[idxUV++] = ir / radialSegments;\n      uvs[idxUV++] = tY;\n    }\n  }\n\n  for (let iy = 0; iy < heightSegments; iy++) {\n    for (let ir = 0; ir < radialSegments; ir++) {\n      const a = iy * (radialSegments + 1) + ir;\n      const b = a + (radialSegments + 1);\n\n      indices.push(a, b, a + 1);\n      indices.push(b, b + 1, a + 1);\n    }\n  }\n\n  const geometry = new THREE.BufferGeometry();\n  geometry.setAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\n  geometry.setAttribute(\"uv\", new THREE.BufferAttribute(uvs, 2));\n  geometry.setIndex(indices);\n  geometry.computeVertexNormals();\n\n  const mat = new THREE.MeshStandardMaterial(materialOptions);\n  return new THREE.Mesh(geometry, mat);\n}\n\n// puntos que pediste:\nconst controlPoints = [\n  { y: 0,   rx: 0,  rz: 0  },\n  { y: 10,  rx: 30, rz: 30 },\n  { y: 20,  rx: 40, rz: 40 },\n  { y: 50,  rx: 50, rz: 50 },\n  { y: 80,  rx: 40, rz: 40 },\n  { y: 90,  rx: 30, rz: 30 },\n  { y: 100, rx: 0,  rz: 0  },\n];\n\nexport default function EllipticalShape() {\n  const mountRef = useRef();\n\n  useEffect(() => {\n    // escena\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(\"#000000\");\n\n    const camera = new THREE.PerspectiveCamera(\n      50,\n      window.innerWidth / window.innerHeight,\n      0.1,\n      1000\n    );\n    camera.position.set(0, 80, 180);\n\n    const renderer = new THREE.WebGLRenderer({ antialias: true });\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    mountRef.current.appendChild(renderer.domElement);\n\n    // luz\n    const light = new THREE.DirectionalLight(0xffffff, 1);\n    light.position.set(50, 100, 50);\n    scene.add(light);\n\n    const ambient = new THREE.AmbientLight(0x888888);\n    scene.add(ambient);\n\n    // ---- aquí se añade tu circunferencia 3D ----\n    const mesh = createEllipticalStackMesh(controlPoints, {\n      height: 100,\n      radialSegments: 64,\n      heightSegments: 200,\n      materialOptions: {\n        side: THREE.DoubleSide,\n        metalness: 0.1,\n        roughness: 0.6,\n        transparent: true,\n        opacity: 0.95,\n        color: 0x22ccff,\n      }\n    });\n\n    mesh.position.set(0, 0, 0);\n    scene.add(mesh);\n\n    // animación\n    function animate() {\n      requestAnimationFrame(animate);\n      mesh.rotation.y += 0.003;\n      renderer.render(scene, camera);\n    }\n    animate();\n\n    // cleanup\n    return () => {\n      mountRef.current.removeChild(renderer.domElement);\n    };\n  }, []);\n\n  return <div ref={mountRef} style={{ width: \"100vw\", height: \"100vh\" }} />;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}