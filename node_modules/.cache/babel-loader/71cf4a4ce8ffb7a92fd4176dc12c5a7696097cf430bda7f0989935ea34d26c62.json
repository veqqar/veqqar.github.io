{"ast":null,"code":"var _jsxFileName = \"/home/johnlemon/portfolio/src/components/extra_functions/SphereAnimation.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect } from \"react\";\nimport * as THREE from \"three\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\n\n// CircleXZAnimation (versión esfera)\n// - Canvas más grande (ocupa toda la ventana)\n// - La \"circunferencia\" en XZ sigue el radio correcto de una esfera de radio R = 50\n//   centrada en y = R: r(y) = sqrt(R^2 - (y - R)^2)\n// - La circunferencia se dibuja como una línea (THREE.Line) y su geometría se actualiza cada frame\n// - Movimiento ping-pong entre y=0 y y=100\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function CircleXZAnimation() {\n  _s();\n  const mountRef = useRef(null);\n  useEffect(() => {\n    const mount = mountRef.current;\n    if (!mount) return;\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x071026);\n    const width = mount.clientWidth;\n    const height = mount.clientHeight;\n    const camera = new THREE.PerspectiveCamera(55, width / height, 0.1, 1000);\n    camera.position.set(0, 140, 260);\n    camera.lookAt(0, 50, 0);\n    const renderer = new THREE.WebGLRenderer({\n      antialias: true\n    });\n    renderer.setSize(width, height);\n    renderer.setPixelRatio(window.devicePixelRatio);\n    mount.appendChild(renderer.domElement);\n\n    // Luces\n    const amb = new THREE.AmbientLight(0xffffff, 0.55);\n    scene.add(amb);\n    const dir = new THREE.DirectionalLight(0xffffff, 0.4);\n    dir.position.set(50, 120, 80);\n    scene.add(dir);\n\n    // Grid para referencia en XZ\n    const grid = new THREE.GridHelper(300, 30, 0x333333, 0x1a1a1a);\n    scene.add(grid);\n\n    // Parámetros de la \"esfera\" (en unidades compatibles con tu petición)\n    const R = 50; // radio de la esfera\n    const Y_MIN = 0;\n    const Y_MAX = 100;\n\n    // Creamos una línea circular en el plano XZ (y = 0), actualizaremos sus vértices para escalarla\n    const segments = 256;\n    const positions = new Float32Array((segments + 1) * 3); // +1 para cerrar el bucle\n\n    const geometry = new THREE.BufferGeometry();\n    geometry.setAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\n    geometry.setDrawRange(0, segments + 1);\n    const material = new THREE.LineBasicMaterial({\n      color: 0x7be495,\n      transparent: true,\n      opacity: 0.95\n    });\n    const circleLine = new THREE.Line(geometry, material);\n    // Por defecto los puntos que generemos estarán en el plano XZ (y = 0); moveremos la línea en Y\n    scene.add(circleLine);\n\n    // Controles (opcionales para inspeccionar)\n    const controls = new OrbitControls(camera, renderer.domElement);\n    controls.target.set(0, 50, 0);\n    controls.update();\n\n    // Reloj y variables de animacion\n    const clock = new THREE.Clock();\n    let y = 0;\n    let dirUp = 1; // 1 subiendo, -1 bajando\n    const speed = 18; // unidades Y por segundo\n\n    // Rellenar posiciones de la circunferencia para un radio dado\n    function updateCircleGeometry(radius) {\n      // radius puede ser 0 -> entonces todos los puntos serán (0,0,0)\n      for (let i = 0; i <= segments; i++) {\n        const t = i / segments * Math.PI * 2;\n        const x = radius * Math.cos(t);\n        const z = radius * Math.sin(t);\n        const idx = i * 3;\n        positions[idx] = x;\n        positions[idx + 1] = 0; // posición local Y, la línea entera se desplazará con circleLine.position.y\n        positions[idx + 2] = z;\n      }\n      // Marcar atributo para que WebGL lo actualice\n      geometry.attributes.position.needsUpdate = true;\n      // Si el radio es 0, mantén la línea visible (un punto), no romperá nada.\n    }\n\n    // Función que devuelve radio de la sección horizontal de una esfera de radio R centrada en y=R\n    function sphereRadiusAtY(yPos) {\n      // r(y) = sqrt(R^2 - (y - R)^2)\n      const val = R * R - (yPos - R) * (yPos - R);\n      return val > 0 ? Math.sqrt(val) : 0;\n    }\n\n    // Inicializamos la geometría en y = 0 (radio 0)\n    updateCircleGeometry(0);\n    circleLine.position.y = 0;\n    function animate() {\n      const delta = clock.getDelta();\n\n      // Actualizamos y\n      y += dirUp * speed * delta;\n      if (y >= Y_MAX) {\n        y = Y_MAX;\n        dirUp = -1;\n      } else if (y <= Y_MIN) {\n        y = Y_MIN;\n        dirUp = 1;\n      }\n\n      // Calculamos radio según la geometría esférica (no exponencial, sino geométricamente correcto)\n      const r = sphereRadiusAtY(y);\n      updateCircleGeometry(r);\n      circleLine.position.y = y;\n      renderer.render(scene, camera);\n      requestAnimationFrame(animate);\n    }\n    clock.start();\n    animate();\n\n    // Resize\n    function handleResize() {\n      const w = mount.clientWidth;\n      const h = mount.clientHeight;\n      camera.aspect = w / h;\n      camera.updateProjectionMatrix();\n      renderer.setSize(w, h);\n    }\n    window.addEventListener(\"resize\", handleResize);\n\n    // Cleanup\n    return () => {\n      window.removeEventListener(\"resize\", handleResize);\n      mount.removeChild(renderer.domElement);\n      geometry.dispose();\n      material.dispose();\n      renderer.dispose();\n      controls.dispose();\n    };\n  }, []);\n\n  // El contenedor ahora ocupa toda la pantalla para que el canvas sea claramente visible\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: mountRef,\n    style: {\n      width: \"100vw\",\n      height: \"100vh\",\n      position: \"relative\"\n    },\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: \"absolute\",\n        left: 12,\n        top: 12,\n        padding: \"6px 10px\",\n        background: \"rgba(0,0,0,0.35)\",\n        color: \"#e6fff0\",\n        borderRadius: 8,\n        fontSize: 13\n      },\n      children: \"Circunferencia (secci\\xF3n de esfera) en XZ \\u2014 y: 0 \\u2192 100, R = 50\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 156,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 155,\n    columnNumber: 5\n  }, this);\n}\n_s(CircleXZAnimation, \"V9/qkEdV8GfsDZk7lMTA1T8g5Ps=\");\n_c = CircleXZAnimation;\nvar _c;\n$RefreshReg$(_c, \"CircleXZAnimation\");","map":{"version":3,"names":["React","useRef","useEffect","THREE","OrbitControls","jsxDEV","_jsxDEV","CircleXZAnimation","_s","mountRef","mount","current","scene","Scene","background","Color","width","clientWidth","height","clientHeight","camera","PerspectiveCamera","position","set","lookAt","renderer","WebGLRenderer","antialias","setSize","setPixelRatio","window","devicePixelRatio","appendChild","domElement","amb","AmbientLight","add","dir","DirectionalLight","grid","GridHelper","R","Y_MIN","Y_MAX","segments","positions","Float32Array","geometry","BufferGeometry","setAttribute","BufferAttribute","setDrawRange","material","LineBasicMaterial","color","transparent","opacity","circleLine","Line","controls","target","update","clock","Clock","y","dirUp","speed","updateCircleGeometry","radius","i","t","Math","PI","x","cos","z","sin","idx","attributes","needsUpdate","sphereRadiusAtY","yPos","val","sqrt","animate","delta","getDelta","r","render","requestAnimationFrame","start","handleResize","w","h","aspect","updateProjectionMatrix","addEventListener","removeEventListener","removeChild","dispose","ref","style","children","left","top","padding","borderRadius","fontSize","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/johnlemon/portfolio/src/components/extra_functions/SphereAnimation.jsx"],"sourcesContent":["import React, { useRef, useEffect } from \"react\";\nimport * as THREE from \"three\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\n\n// CircleXZAnimation (versión esfera)\n// - Canvas más grande (ocupa toda la ventana)\n// - La \"circunferencia\" en XZ sigue el radio correcto de una esfera de radio R = 50\n//   centrada en y = R: r(y) = sqrt(R^2 - (y - R)^2)\n// - La circunferencia se dibuja como una línea (THREE.Line) y su geometría se actualiza cada frame\n// - Movimiento ping-pong entre y=0 y y=100\n\nexport default function CircleXZAnimation() {\n  const mountRef = useRef(null);\n\n  useEffect(() => {\n    const mount = mountRef.current;\n    if (!mount) return;\n\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x071026);\n\n    const width = mount.clientWidth;\n    const height = mount.clientHeight;\n\n    const camera = new THREE.PerspectiveCamera(55, width / height, 0.1, 1000);\n    camera.position.set(0, 140, 260);\n    camera.lookAt(0, 50, 0);\n\n    const renderer = new THREE.WebGLRenderer({ antialias: true });\n    renderer.setSize(width, height);\n    renderer.setPixelRatio(window.devicePixelRatio);\n    mount.appendChild(renderer.domElement);\n\n    // Luces\n    const amb = new THREE.AmbientLight(0xffffff, 0.55);\n    scene.add(amb);\n    const dir = new THREE.DirectionalLight(0xffffff, 0.4);\n    dir.position.set(50, 120, 80);\n    scene.add(dir);\n\n    // Grid para referencia en XZ\n    const grid = new THREE.GridHelper(300, 30, 0x333333, 0x1a1a1a);\n    scene.add(grid);\n\n    // Parámetros de la \"esfera\" (en unidades compatibles con tu petición)\n    const R = 50; // radio de la esfera\n    const Y_MIN = 0;\n    const Y_MAX = 100;\n\n    // Creamos una línea circular en el plano XZ (y = 0), actualizaremos sus vértices para escalarla\n    const segments = 256;\n    const positions = new Float32Array((segments + 1) * 3); // +1 para cerrar el bucle\n\n    const geometry = new THREE.BufferGeometry();\n    geometry.setAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\n    geometry.setDrawRange(0, segments + 1);\n\n    const material = new THREE.LineBasicMaterial({\n      color: 0x7be495,\n      transparent: true,\n      opacity: 0.95,\n    });\n\n    const circleLine = new THREE.Line(geometry, material);\n    // Por defecto los puntos que generemos estarán en el plano XZ (y = 0); moveremos la línea en Y\n    scene.add(circleLine);\n\n    // Controles (opcionales para inspeccionar)\n    const controls = new OrbitControls(camera, renderer.domElement);\n    controls.target.set(0, 50, 0);\n    controls.update();\n\n    // Reloj y variables de animacion\n    const clock = new THREE.Clock();\n    let y = 0;\n    let dirUp = 1; // 1 subiendo, -1 bajando\n    const speed = 18; // unidades Y por segundo\n\n    // Rellenar posiciones de la circunferencia para un radio dado\n    function updateCircleGeometry(radius) {\n      // radius puede ser 0 -> entonces todos los puntos serán (0,0,0)\n      for (let i = 0; i <= segments; i++) {\n        const t = (i / segments) * Math.PI * 2;\n        const x = radius * Math.cos(t);\n        const z = radius * Math.sin(t);\n        const idx = i * 3;\n        positions[idx] = x;\n        positions[idx + 1] = 0; // posición local Y, la línea entera se desplazará con circleLine.position.y\n        positions[idx + 2] = z;\n      }\n      // Marcar atributo para que WebGL lo actualice\n      geometry.attributes.position.needsUpdate = true;\n      // Si el radio es 0, mantén la línea visible (un punto), no romperá nada.\n    }\n\n    // Función que devuelve radio de la sección horizontal de una esfera de radio R centrada en y=R\n    function sphereRadiusAtY(yPos) {\n      // r(y) = sqrt(R^2 - (y - R)^2)\n      const val = R * R - (yPos - R) * (yPos - R);\n      return val > 0 ? Math.sqrt(val) : 0;\n    }\n\n    // Inicializamos la geometría en y = 0 (radio 0)\n    updateCircleGeometry(0);\n    circleLine.position.y = 0;\n\n    function animate() {\n      const delta = clock.getDelta();\n\n      // Actualizamos y\n      y += dirUp * speed * delta;\n      if (y >= Y_MAX) {\n        y = Y_MAX;\n        dirUp = -1;\n      } else if (y <= Y_MIN) {\n        y = Y_MIN;\n        dirUp = 1;\n      }\n\n      // Calculamos radio según la geometría esférica (no exponencial, sino geométricamente correcto)\n      const r = sphereRadiusAtY(y);\n      updateCircleGeometry(r);\n      circleLine.position.y = y;\n\n      renderer.render(scene, camera);\n      requestAnimationFrame(animate);\n    }\n\n    clock.start();\n    animate();\n\n    // Resize\n    function handleResize() {\n      const w = mount.clientWidth;\n      const h = mount.clientHeight;\n      camera.aspect = w / h;\n      camera.updateProjectionMatrix();\n      renderer.setSize(w, h);\n    }\n    window.addEventListener(\"resize\", handleResize);\n\n    // Cleanup\n    return () => {\n      window.removeEventListener(\"resize\", handleResize);\n      mount.removeChild(renderer.domElement);\n      geometry.dispose();\n      material.dispose();\n      renderer.dispose();\n      controls.dispose();\n    };\n  }, []);\n\n  // El contenedor ahora ocupa toda la pantalla para que el canvas sea claramente visible\n  return (\n    <div ref={mountRef} style={{ width: \"100vw\", height: \"100vh\", position: \"relative\" }}>\n      <div style={{ position: \"absolute\", left: 12, top: 12, padding: \"6px 10px\", background: \"rgba(0,0,0,0.35)\", color: \"#e6fff0\", borderRadius: 8, fontSize: 13 }}>\n        Circunferencia (sección de esfera) en XZ — y: 0 → 100, R = 50\n      </div>\n    </div>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}