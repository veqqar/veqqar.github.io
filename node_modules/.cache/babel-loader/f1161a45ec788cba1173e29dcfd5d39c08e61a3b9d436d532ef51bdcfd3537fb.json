{"ast":null,"code":"import React, { useRef, useEffect } from \"react\";\nimport * as THREE from \"three\";\n\n// Requiere THREE already loaded, y un `scene` existente.\n// Función: createEllipticalStackMesh(controlPoints, options)\n// controlPoints: array de { y: Number, rx: Number, rz: Number }\n// Ejemplo de los puntos que diste:\n// [\n//   { y: 0,   rx: 0,  rz: 0  },\n//   { y: 10,  rx: 30, rz: 30 },\n//   { y: 20,  rx: 40, rz: 40 },\n//   { y: 50,  rx: 50, rz: 50 },\n//   { y: 80,  rx: 40, rz: 40 },\n//   { y: 90,  rx: 30, rz: 30 },\n//   { y: 100, rx: 0,  rz: 0  }\n// ]\nfunction createEllipticalStackMesh(controlPoints, options = {}) {\n  var _options$height, _options$radialSegmen, _options$heightSegmen, _options$closed, _options$materialOpti;\n  const height = (_options$height = options.height) !== null && _options$height !== void 0 ? _options$height : 100; // altura total (se usa como referencia)\n  const radialSegments = (_options$radialSegmen = options.radialSegments) !== null && _options$radialSegmen !== void 0 ? _options$radialSegmen : 64; // puntos por circunferencia\n  const heightSegments = (_options$heightSegmen = options.heightSegments) !== null && _options$heightSegmen !== void 0 ? _options$heightSegmen : 100; // anillos verticales (muestreo en Y)\n  const closed = (_options$closed = options.closed) !== null && _options$closed !== void 0 ? _options$closed : false; // si cerrar la topología en Y (no necesario aquí)\n  const materialOptions = (_options$materialOpti = options.materialOptions) !== null && _options$materialOpti !== void 0 ? _options$materialOpti : {\n    side: THREE.DoubleSide,\n    transparent: true,\n    opacity: 0.9\n  };\n\n  // ordenar controlPoints por y por si acaso\n  controlPoints = controlPoints.slice().sort((a, b) => a.y - b.y);\n\n  // helper: interpola linealmente rx/rz para una y dada\n  function interpRadiiForY(y) {\n    // si está fuera de los extremos, devolver extremo correspondiente\n    if (y <= controlPoints[0].y) return {\n      rx: controlPoints[0].rx,\n      rz: controlPoints[0].rz\n    };\n    if (y >= controlPoints[controlPoints.length - 1].y) {\n      const p = controlPoints[controlPoints.length - 1];\n      return {\n        rx: p.rx,\n        rz: p.rz\n      };\n    }\n    // buscar segmento\n    for (let i = 0; i < controlPoints.length - 1; i++) {\n      const a = controlPoints[i];\n      const b = controlPoints[i + 1];\n      if (y >= a.y && y <= b.y) {\n        const t = (y - a.y) / (b.y - a.y); // 0..1\n        const rx = a.rx + (b.rx - a.rx) * t;\n        const rz = a.rz + (b.rz - a.rz) * t;\n        return {\n          rx,\n          rz\n        };\n      }\n    }\n    // fallback (no debería llegar aquí)\n    return {\n      rx: 0,\n      rz: 0\n    };\n  }\n\n  // Construir arrays\n  const vertsCount = (heightSegments + 1) * (radialSegments + 1);\n  const positions = new Float32Array(vertsCount * 3);\n  const uvs = new Float32Array(vertsCount * 2);\n  // indices para triángulos\n  const indices = [];\n\n  // Rellenar posiciones\n  let idxPos = 0;\n  let idxUV = 0;\n  for (let iy = 0; iy <= heightSegments; iy++) {\n    const tY = iy / heightSegments; // 0..1\n    const y = tY * height; // 0..height\n    const {\n      rx,\n      rz\n    } = interpRadiiForY(y);\n    for (let ir = 0; ir <= radialSegments; ir++) {\n      const theta = ir / radialSegments * Math.PI * 2;\n      const x = rx * Math.cos(theta);\n      const z = rz * Math.sin(theta);\n      positions[idxPos++] = x;\n      positions[idxPos++] = y;\n      positions[idxPos++] = z;\n      uvs[idxUV++] = ir / radialSegments;\n      uvs[idxUV++] = tY;\n    }\n  }\n\n  // Crear índices (tri-strips por cada rectángulo entre anillos)\n  for (let iy = 0; iy < heightSegments; iy++) {\n    for (let ir = 0; ir < radialSegments; ir++) {\n      const a = iy * (radialSegments + 1) + ir;\n      const b = a + (radialSegments + 1);\n      // dos triángulos: (a, b, a+1) y (b, b+1, a+1)\n      indices.push(a, b, a + 1);\n      indices.push(b, b + 1, a + 1);\n    }\n  }\n\n  // Construir BufferGeometry\n  const geometry = new THREE.BufferGeometry();\n  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n  geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));\n  geometry.setIndex(indices);\n  geometry.computeVertexNormals();\n\n  // Material y malla\n  const mat = new THREE.MeshStandardMaterial(materialOptions);\n  const mesh = new THREE.Mesh(geometry, mat);\n  return mesh; // añadir al scene con scene.add(mesh)\n}\n\n// --- USO con los datos que indicaste ---\nconst controlPoints = [{\n  y: 0,\n  rx: 0,\n  rz: 0\n}, {\n  y: 10,\n  rx: 30,\n  rz: 30\n}, {\n  y: 20,\n  rx: 40,\n  rz: 40\n}, {\n  y: 50,\n  rx: 50,\n  rz: 50\n}, {\n  y: 80,\n  rx: 40,\n  rz: 40\n}, {\n  y: 90,\n  rx: 30,\n  rz: 30\n}, {\n  y: 100,\n  rx: 0,\n  rz: 0\n}];\n\n// ejemplo: crear y añadir a la escena\nconst mesh = createEllipticalStackMesh(controlPoints, {\n  height: 100,\n  radialSegments: 64,\n  heightSegments: 200,\n  materialOptions: {\n    side: THREE.DoubleSide,\n    metalness: 0.1,\n    roughness: 0.6,\n    wireframe: false,\n    opacity: 0.95,\n    transparent: true\n  }\n});\nscene.add(mesh);\n\n// Opcional: para ver solo las circunferencias (wireframe de anillos) en vez de una superficie:\nfunction createRingLines(controlPoints, options = {}) {\n  var _options$radialSegmen2, _options$heightSegmen2, _options$height2;\n  // crea un THREE.LineSegments con muchas circunferencias (no triangula)\n  const radialSegments = (_options$radialSegmen2 = options.radialSegments) !== null && _options$radialSegmen2 !== void 0 ? _options$radialSegmen2 : 64;\n  const heightSegments = (_options$heightSegmen2 = options.heightSegments) !== null && _options$heightSegmen2 !== void 0 ? _options$heightSegmen2 : 40;\n  const height = (_options$height2 = options.height) !== null && _options$height2 !== void 0 ? _options$height2 : 100;\n  const geometry = new THREE.BufferGeometry();\n  const positions = [];\n  for (let iy = 0; iy <= heightSegments; iy++) {\n    const tY = iy / heightSegments;\n    const y = tY * height;\n    const {\n      rx,\n      rz\n    } = function (yVal) {\n      // reutiliza la función de arriba (se puede mover fuera para compartir)\n      if (yVal <= controlPoints[0].y) return controlPoints[0];\n      if (yVal >= controlPoints[controlPoints.length - 1].y) return controlPoints[controlPoints.length - 1];\n      for (let i = 0; i < controlPoints.length - 1; i++) {\n        const a = controlPoints[i],\n          b = controlPoints[i + 1];\n        if (yVal >= a.y && yVal <= b.y) {\n          const t = (yVal - a.y) / (b.y - a.y);\n          return {\n            rx: a.rx + (b.rx - a.rx) * t,\n            rz: a.rz + (b.rz - a.rz) * t\n          };\n        }\n      }\n      return {\n        rx: 0,\n        rz: 0\n      };\n    }(y);\n    for (let ir = 0; ir <= radialSegments; ir++) {\n      const theta = ir / radialSegments * Math.PI * 2;\n      positions.push(rx * Math.cos(theta), y, rz * Math.sin(theta));\n      // conectar con siguiente punto de la misma circunferencia (si quieres segmentos continuos)\n    }\n  }\n  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n  const mat = new THREE.LineBasicMaterial({\n    color: 0x00ffdd,\n    transparent: true,\n    opacity: 0.9\n  });\n  const lines = new THREE.Line(geometry, mat);\n  return lines;\n}\n\n// ejemplo: scene.add(createRingLines(controlPoints, { radialSegments: 64, heightSegments: 80, height: 100 }));","map":{"version":3,"names":["React","useRef","useEffect","THREE","createEllipticalStackMesh","controlPoints","options","_options$height","_options$radialSegmen","_options$heightSegmen","_options$closed","_options$materialOpti","height","radialSegments","heightSegments","closed","materialOptions","side","DoubleSide","transparent","opacity","slice","sort","a","b","y","interpRadiiForY","rx","rz","length","p","i","t","vertsCount","positions","Float32Array","uvs","indices","idxPos","idxUV","iy","tY","ir","theta","Math","PI","x","cos","z","sin","push","geometry","BufferGeometry","setAttribute","BufferAttribute","setIndex","computeVertexNormals","mat","MeshStandardMaterial","mesh","Mesh","metalness","roughness","wireframe","scene","add","createRingLines","_options$radialSegmen2","_options$heightSegmen2","_options$height2","yVal","Float32BufferAttribute","LineBasicMaterial","color","lines","Line"],"sources":["/home/johnlemon/portfolio/src/components/extra_functions/SphereAnimation.jsx"],"sourcesContent":["import React, { useRef, useEffect } from \"react\";\nimport * as THREE from \"three\";\n\n// Requiere THREE already loaded, y un `scene` existente.\n// Función: createEllipticalStackMesh(controlPoints, options)\n// controlPoints: array de { y: Number, rx: Number, rz: Number }\n// Ejemplo de los puntos que diste:\n// [\n//   { y: 0,   rx: 0,  rz: 0  },\n//   { y: 10,  rx: 30, rz: 30 },\n//   { y: 20,  rx: 40, rz: 40 },\n//   { y: 50,  rx: 50, rz: 50 },\n//   { y: 80,  rx: 40, rz: 40 },\n//   { y: 90,  rx: 30, rz: 30 },\n//   { y: 100, rx: 0,  rz: 0  }\n// ]\nfunction createEllipticalStackMesh(controlPoints, options = {}) {\n  const height = options.height ?? 100; // altura total (se usa como referencia)\n  const radialSegments = options.radialSegments ?? 64; // puntos por circunferencia\n  const heightSegments = options.heightSegments ?? 100; // anillos verticales (muestreo en Y)\n  const closed = options.closed ?? false; // si cerrar la topología en Y (no necesario aquí)\n  const materialOptions = options.materialOptions ?? { side: THREE.DoubleSide, transparent: true, opacity: 0.9 };\n\n  // ordenar controlPoints por y por si acaso\n  controlPoints = controlPoints.slice().sort((a, b) => a.y - b.y);\n\n  // helper: interpola linealmente rx/rz para una y dada\n  function interpRadiiForY(y) {\n    // si está fuera de los extremos, devolver extremo correspondiente\n    if (y <= controlPoints[0].y) return { rx: controlPoints[0].rx, rz: controlPoints[0].rz };\n    if (y >= controlPoints[controlPoints.length - 1].y) {\n      const p = controlPoints[controlPoints.length - 1];\n      return { rx: p.rx, rz: p.rz };\n    }\n    // buscar segmento\n    for (let i = 0; i < controlPoints.length - 1; i++) {\n      const a = controlPoints[i];\n      const b = controlPoints[i + 1];\n      if (y >= a.y && y <= b.y) {\n        const t = (y - a.y) / (b.y - a.y); // 0..1\n        const rx = a.rx + (b.rx - a.rx) * t;\n        const rz = a.rz + (b.rz - a.rz) * t;\n        return { rx, rz };\n      }\n    }\n    // fallback (no debería llegar aquí)\n    return { rx: 0, rz: 0 };\n  }\n\n  // Construir arrays\n  const vertsCount = (heightSegments + 1) * (radialSegments + 1);\n  const positions = new Float32Array(vertsCount * 3);\n  const uvs = new Float32Array(vertsCount * 2);\n  // indices para triángulos\n  const indices = [];\n\n  // Rellenar posiciones\n  let idxPos = 0;\n  let idxUV = 0;\n  for (let iy = 0; iy <= heightSegments; iy++) {\n    const tY = iy / heightSegments; // 0..1\n    const y = tY * height; // 0..height\n    const { rx, rz } = interpRadiiForY(y);\n\n    for (let ir = 0; ir <= radialSegments; ir++) {\n      const theta = (ir / radialSegments) * Math.PI * 2;\n      const x = rx * Math.cos(theta);\n      const z = rz * Math.sin(theta);\n      positions[idxPos++] = x;\n      positions[idxPos++] = y;\n      positions[idxPos++] = z;\n\n      uvs[idxUV++] = ir / radialSegments;\n      uvs[idxUV++] = tY;\n    }\n  }\n\n  // Crear índices (tri-strips por cada rectángulo entre anillos)\n  for (let iy = 0; iy < heightSegments; iy++) {\n    for (let ir = 0; ir < radialSegments; ir++) {\n      const a = iy * (radialSegments + 1) + ir;\n      const b = a + (radialSegments + 1);\n      // dos triángulos: (a, b, a+1) y (b, b+1, a+1)\n      indices.push(a, b, a + 1);\n      indices.push(b, b + 1, a + 1);\n    }\n  }\n\n  // Construir BufferGeometry\n  const geometry = new THREE.BufferGeometry();\n  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n  geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));\n  geometry.setIndex(indices);\n  geometry.computeVertexNormals();\n\n  // Material y malla\n  const mat = new THREE.MeshStandardMaterial(materialOptions);\n  const mesh = new THREE.Mesh(geometry, mat);\n\n  return mesh; // añadir al scene con scene.add(mesh)\n}\n\n// --- USO con los datos que indicaste ---\nconst controlPoints = [\n  { y: 0,   rx: 0,  rz: 0  },\n  { y: 10,  rx: 30, rz: 30 },\n  { y: 20,  rx: 40, rz: 40 },\n  { y: 50,  rx: 50, rz: 50 },\n  { y: 80,  rx: 40, rz: 40 },\n  { y: 90,  rx: 30, rz: 30 },\n  { y: 100, rx: 0,  rz: 0  }\n];\n\n// ejemplo: crear y añadir a la escena\nconst mesh = createEllipticalStackMesh(controlPoints, {\n  height: 100,\n  radialSegments: 64,\n  heightSegments: 200,\n  materialOptions: { side: THREE.DoubleSide, metalness: 0.1, roughness: 0.6, wireframe: false, opacity: 0.95, transparent: true }\n});\nscene.add(mesh);\n\n// Opcional: para ver solo las circunferencias (wireframe de anillos) en vez de una superficie:\nfunction createRingLines(controlPoints, options = {}) {\n  // crea un THREE.LineSegments con muchas circunferencias (no triangula)\n  const radialSegments = options.radialSegments ?? 64;\n  const heightSegments = options.heightSegments ?? 40;\n  const height = options.height ?? 100;\n  const geometry = new THREE.BufferGeometry();\n  const positions = [];\n  for (let iy = 0; iy <= heightSegments; iy++) {\n    const tY = iy / heightSegments;\n    const y = tY * height;\n    const { rx, rz } = (function(yVal){\n      // reutiliza la función de arriba (se puede mover fuera para compartir)\n      if (yVal <= controlPoints[0].y) return controlPoints[0];\n      if (yVal >= controlPoints[controlPoints.length-1].y) return controlPoints[controlPoints.length-1];\n      for (let i=0;i<controlPoints.length-1;i++){\n        const a = controlPoints[i], b = controlPoints[i+1];\n        if (yVal>=a.y && yVal<=b.y) {\n          const t = (yVal - a.y) / (b.y - a.y);\n          return { rx: a.rx + (b.rx-a.rx)*t, rz: a.rz + (b.rz-a.rz)*t };\n        }\n      }\n      return { rx:0, rz:0 };\n    })(y);\n\n    for (let ir = 0; ir <= radialSegments; ir++) {\n      const theta = (ir / radialSegments) * Math.PI * 2;\n      positions.push(rx * Math.cos(theta), y, rz * Math.sin(theta));\n      // conectar con siguiente punto de la misma circunferencia (si quieres segmentos continuos)\n    }\n  }\n  geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n  const mat = new THREE.LineBasicMaterial({ color: 0x00ffdd, transparent: true, opacity: 0.9 });\n  const lines = new THREE.Line(geometry, mat);\n  return lines;\n}\n\n// ejemplo: scene.add(createRingLines(controlPoints, { radialSegments: 64, heightSegments: 80, height: 100 }));\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}