{"ast":null,"code":"var _jsxFileName = \"/home/johnlemon/portfolio/src/components/extra_functions/DecryptedText.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState, useMemo } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst DEFAULT_CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%&*()_+-=[]{};:\\'\",.<>/?';\nexport default function DecryptedText({\n  text = \"VEQQAR\",\n  encryptedText = \"V3QQ42\",\n  iterations = 10,\n  // 10 iteraciones por letra\n  speed = 35,\n  // ms entre iteraciones\n  charset = DEFAULT_CHARSET,\n  className = 'decrypted-text',\n  encryptedClassName = 'encrypted-text',\n  parentClassName = 'decrypted-text-container',\n  ...props\n}) {\n  _s();\n  // estado visible (array de caracteres para updates puntuales)\n  const [displayChars, setDisplayChars] = useState(() => encryptedText.split(''));\n\n  // token para cancelar animaciones previas\n  const animTokenRef = useRef(0);\n  // flag de hover\n  const hoveringRef = useRef(false);\n\n  // indices donde encryptedText y text difieren (en orden izquierda->derecha)\n  const diffIndices = useMemo(() => {\n    const diffs = [];\n    const minLen = Math.min(text.length, encryptedText.length);\n    for (let i = 0; i < Math.max(text.length, encryptedText.length); i++) {\n      var _encryptedText$i, _text$i;\n      const enc = (_encryptedText$i = encryptedText[i]) !== null && _encryptedText$i !== void 0 ? _encryptedText$i : '';\n      const dec = (_text$i = text[i]) !== null && _text$i !== void 0 ? _text$i : '';\n      if (enc !== dec) diffs.push(i);\n    }\n    return diffs;\n  }, [text, encryptedText]);\n  useEffect(() => {\n    // si cambian props, sincronizamos la visual con encryptedText por defecto\n    setDisplayChars(encryptedText.split(''));\n    // cancelar animaciones activas\n    animTokenRef.current++;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [encryptedText, text]);\n\n  // helper: caracter aleatorio\n  const randomChar = () => charset[Math.floor(Math.random() * charset.length)];\n\n  // animación secuencial: para cada índice en diffIndices hacemos `iterations` cambios y luego fijamos el valor final\n  const runAnimation = async () => {\n    const myToken = ++animTokenRef.current;\n    for (const idx of diffIndices) {\n      // si token ha cambiado o se dejó de hacer hover, abortamos\n      if (animTokenRef.current !== myToken || !hoveringRef.current) return;\n      for (let i = 0; i < iterations; i++) {\n        if (animTokenRef.current !== myToken || !hoveringRef.current) return;\n        setDisplayChars(prev => {\n          const copy = prev.slice();\n          copy[idx] = randomChar();\n          return copy;\n        });\n        // espera\n        await new Promise(res => setTimeout(res, speed));\n      }\n\n      // poner la letra correcta\n      if (animTokenRef.current !== myToken || !hoveringRef.current) return;\n      setDisplayChars(prev => {\n        var _text$idx;\n        const copy = prev.slice();\n        copy[idx] = (_text$idx = text[idx]) !== null && _text$idx !== void 0 ? _text$idx : '';\n        return copy;\n      });\n\n      // pequeño retardo antes de pasar a la siguiente letra (opcional)\n      await new Promise(res => setTimeout(res, speed));\n    }\n\n    // al terminar la secuencia, nos quedamos con el texto final (completo)\n    if (animTokenRef.current === myToken && hoveringRef.current) {\n      setDisplayChars(text.split(''));\n    }\n  };\n\n  // handlers del hover\n  const handleMouseEnter = () => {\n    hoveringRef.current = true;\n    // iniciar animación (cancelará cualquier ejecución previa por token)\n    runAnimation();\n  };\n  const handleMouseLeave = () => {\n    hoveringRef.current = false;\n    // incrementar token para cancelar cualquier animación en curso\n    animTokenRef.current++;\n    // volver al estado encriptado\n    setDisplayChars(encryptedText.split(''));\n  };\n  return /*#__PURE__*/_jsxDEV(\"span\", {\n    className: parentClassName,\n    onMouseEnter: handleMouseEnter,\n    onMouseLeave: handleMouseLeave,\n    \"aria-label\": text,\n    ...props,\n    style: {\n      cursor: 'pointer',\n      display: 'inline-block'\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"span\", {\n      style: {\n        position: 'absolute',\n        width: 1,\n        height: 1,\n        padding: 0,\n        margin: '-1px',\n        overflow: 'hidden',\n        clip: 'rect(0,0,0,0)',\n        border: 0\n      },\n      \"aria-hidden\": \"true\",\n      children: displayChars.join('')\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 107,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n      \"aria-hidden\": \"true\",\n      children: displayChars.map((ch, i) => {\n        var _text$i2, _encryptedText$i2;\n        // aplica clase \"decrypted\" cuando coincide con letra final; \"encrypted\" cuando coincide con la original encriptada\n        const isFinal = ch === ((_text$i2 = text[i]) !== null && _text$i2 !== void 0 ? _text$i2 : '');\n        const isEncrypted = ch === ((_encryptedText$i2 = encryptedText[i]) !== null && _encryptedText$i2 !== void 0 ? _encryptedText$i2 : '');\n        const cls = isFinal ? className : isEncrypted ? encryptedClassName : encryptedClassName;\n        return /*#__PURE__*/_jsxDEV(\"span\", {\n          className: cls,\n          children: ch\n        }, i, false, {\n          fileName: _jsxFileName,\n          lineNumber: 118,\n          columnNumber: 13\n        }, this);\n      })\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 111,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 99,\n    columnNumber: 5\n  }, this);\n}\n_s(DecryptedText, \"NmOp/P1/khb/ZfzucpTAu1dIl3g=\");\n_c = DecryptedText;\nvar _c;\n$RefreshReg$(_c, \"DecryptedText\");","map":{"version":3,"names":["React","useEffect","useRef","useState","useMemo","jsxDEV","_jsxDEV","DEFAULT_CHARSET","DecryptedText","text","encryptedText","iterations","speed","charset","className","encryptedClassName","parentClassName","props","_s","displayChars","setDisplayChars","split","animTokenRef","hoveringRef","diffIndices","diffs","minLen","Math","min","length","i","max","_encryptedText$i","_text$i","enc","dec","push","current","randomChar","floor","random","runAnimation","myToken","idx","prev","copy","slice","Promise","res","setTimeout","_text$idx","handleMouseEnter","handleMouseLeave","onMouseEnter","onMouseLeave","style","cursor","display","children","position","width","height","padding","margin","overflow","clip","border","join","fileName","_jsxFileName","lineNumber","columnNumber","map","ch","_text$i2","_encryptedText$i2","isFinal","isEncrypted","cls","_c","$RefreshReg$"],"sources":["/home/johnlemon/portfolio/src/components/extra_functions/DecryptedText.jsx"],"sourcesContent":["import React, { useEffect, useRef, useState, useMemo } from 'react';\n\nconst DEFAULT_CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%&*()_+-=[]{};:\\'\",.<>/?';\n\nexport default function DecryptedText({\n  text = \"VEQQAR\",\n  encryptedText = \"V3QQ42\",\n  iterations = 10,         // 10 iteraciones por letra\n  speed = 35,              // ms entre iteraciones\n  charset = DEFAULT_CHARSET,\n  className = 'decrypted-text',\n  encryptedClassName = 'encrypted-text',\n  parentClassName = 'decrypted-text-container',\n  ...props\n}) {\n  // estado visible (array de caracteres para updates puntuales)\n  const [displayChars, setDisplayChars] = useState(() => encryptedText.split(''));\n\n  // token para cancelar animaciones previas\n  const animTokenRef = useRef(0);\n  // flag de hover\n  const hoveringRef = useRef(false);\n\n  // indices donde encryptedText y text difieren (en orden izquierda->derecha)\n  const diffIndices = useMemo(() => {\n    const diffs = [];\n    const minLen = Math.min(text.length, encryptedText.length);\n    for (let i = 0; i < Math.max(text.length, encryptedText.length); i++) {\n      const enc = encryptedText[i] ?? '';\n      const dec = text[i] ?? '';\n      if (enc !== dec) diffs.push(i);\n    }\n    return diffs;\n  }, [text, encryptedText]);\n\n  useEffect(() => {\n    // si cambian props, sincronizamos la visual con encryptedText por defecto\n    setDisplayChars(encryptedText.split(''));\n    // cancelar animaciones activas\n    animTokenRef.current++;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [encryptedText, text]);\n\n  // helper: caracter aleatorio\n  const randomChar = () => charset[Math.floor(Math.random() * charset.length)];\n\n  // animación secuencial: para cada índice en diffIndices hacemos `iterations` cambios y luego fijamos el valor final\n  const runAnimation = async () => {\n    const myToken = ++animTokenRef.current;\n    for (const idx of diffIndices) {\n      // si token ha cambiado o se dejó de hacer hover, abortamos\n      if (animTokenRef.current !== myToken || !hoveringRef.current) return;\n\n      for (let i = 0; i < iterations; i++) {\n        if (animTokenRef.current !== myToken || !hoveringRef.current) return;\n        setDisplayChars(prev => {\n          const copy = prev.slice();\n          copy[idx] = randomChar();\n          return copy;\n        });\n        // espera\n        await new Promise(res => setTimeout(res, speed));\n      }\n\n      // poner la letra correcta\n      if (animTokenRef.current !== myToken || !hoveringRef.current) return;\n      setDisplayChars(prev => {\n        const copy = prev.slice();\n        copy[idx] = text[idx] ?? '';\n        return copy;\n      });\n\n      // pequeño retardo antes de pasar a la siguiente letra (opcional)\n      await new Promise(res => setTimeout(res, speed));\n    }\n\n    // al terminar la secuencia, nos quedamos con el texto final (completo)\n    if (animTokenRef.current === myToken && hoveringRef.current) {\n      setDisplayChars(text.split(''));\n    }\n  };\n\n  // handlers del hover\n  const handleMouseEnter = () => {\n    hoveringRef.current = true;\n    // iniciar animación (cancelará cualquier ejecución previa por token)\n    runAnimation();\n  };\n\n  const handleMouseLeave = () => {\n    hoveringRef.current = false;\n    // incrementar token para cancelar cualquier animación en curso\n    animTokenRef.current++;\n    // volver al estado encriptado\n    setDisplayChars(encryptedText.split(''));\n  };\n\n  return (\n    <span\n      className={parentClassName}\n      onMouseEnter={handleMouseEnter}\n      onMouseLeave={handleMouseLeave}\n      aria-label={text}\n      {...props}\n      style={{ cursor: 'pointer', display: 'inline-block' }}\n    >\n      <span style={{ position: 'absolute', width: 1, height: 1, padding: 0, margin: '-1px', overflow: 'hidden', clip: 'rect(0,0,0,0)', border: 0 }} aria-hidden=\"true\">\n        {displayChars.join('')}\n      </span>\n\n      <span aria-hidden=\"true\">\n        {displayChars.map((ch, i) => {\n          // aplica clase \"decrypted\" cuando coincide con letra final; \"encrypted\" cuando coincide con la original encriptada\n          const isFinal = ch === (text[i] ?? '');\n          const isEncrypted = ch === (encryptedText[i] ?? '');\n          const cls = isFinal ? className : (isEncrypted ? encryptedClassName : encryptedClassName);\n          return (\n            <span key={i} className={cls}>\n              {ch}\n            </span>\n          );\n        })}\n      </span>\n    </span>\n  );\n}\n"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,MAAM,EAAEC,QAAQ,EAAEC,OAAO,QAAQ,OAAO;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEpE,MAAMC,eAAe,GAAG,4FAA4F;AAEpH,eAAe,SAASC,aAAaA,CAAC;EACpCC,IAAI,GAAG,QAAQ;EACfC,aAAa,GAAG,QAAQ;EACxBC,UAAU,GAAG,EAAE;EAAU;EACzBC,KAAK,GAAG,EAAE;EAAe;EACzBC,OAAO,GAAGN,eAAe;EACzBO,SAAS,GAAG,gBAAgB;EAC5BC,kBAAkB,GAAG,gBAAgB;EACrCC,eAAe,GAAG,0BAA0B;EAC5C,GAAGC;AACL,CAAC,EAAE;EAAAC,EAAA;EACD;EACA,MAAM,CAACC,YAAY,EAAEC,eAAe,CAAC,GAAGjB,QAAQ,CAAC,MAAMO,aAAa,CAACW,KAAK,CAAC,EAAE,CAAC,CAAC;;EAE/E;EACA,MAAMC,YAAY,GAAGpB,MAAM,CAAC,CAAC,CAAC;EAC9B;EACA,MAAMqB,WAAW,GAAGrB,MAAM,CAAC,KAAK,CAAC;;EAEjC;EACA,MAAMsB,WAAW,GAAGpB,OAAO,CAAC,MAAM;IAChC,MAAMqB,KAAK,GAAG,EAAE;IAChB,MAAMC,MAAM,GAAGC,IAAI,CAACC,GAAG,CAACnB,IAAI,CAACoB,MAAM,EAAEnB,aAAa,CAACmB,MAAM,CAAC;IAC1D,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,IAAI,CAACI,GAAG,CAACtB,IAAI,CAACoB,MAAM,EAAEnB,aAAa,CAACmB,MAAM,CAAC,EAAEC,CAAC,EAAE,EAAE;MAAA,IAAAE,gBAAA,EAAAC,OAAA;MACpE,MAAMC,GAAG,IAAAF,gBAAA,GAAGtB,aAAa,CAACoB,CAAC,CAAC,cAAAE,gBAAA,cAAAA,gBAAA,GAAI,EAAE;MAClC,MAAMG,GAAG,IAAAF,OAAA,GAAGxB,IAAI,CAACqB,CAAC,CAAC,cAAAG,OAAA,cAAAA,OAAA,GAAI,EAAE;MACzB,IAAIC,GAAG,KAAKC,GAAG,EAAEV,KAAK,CAACW,IAAI,CAACN,CAAC,CAAC;IAChC;IACA,OAAOL,KAAK;EACd,CAAC,EAAE,CAAChB,IAAI,EAAEC,aAAa,CAAC,CAAC;EAEzBT,SAAS,CAAC,MAAM;IACd;IACAmB,eAAe,CAACV,aAAa,CAACW,KAAK,CAAC,EAAE,CAAC,CAAC;IACxC;IACAC,YAAY,CAACe,OAAO,EAAE;IACtB;EACF,CAAC,EAAE,CAAC3B,aAAa,EAAED,IAAI,CAAC,CAAC;;EAEzB;EACA,MAAM6B,UAAU,GAAGA,CAAA,KAAMzB,OAAO,CAACc,IAAI,CAACY,KAAK,CAACZ,IAAI,CAACa,MAAM,CAAC,CAAC,GAAG3B,OAAO,CAACgB,MAAM,CAAC,CAAC;;EAE5E;EACA,MAAMY,YAAY,GAAG,MAAAA,CAAA,KAAY;IAC/B,MAAMC,OAAO,GAAG,EAAEpB,YAAY,CAACe,OAAO;IACtC,KAAK,MAAMM,GAAG,IAAInB,WAAW,EAAE;MAC7B;MACA,IAAIF,YAAY,CAACe,OAAO,KAAKK,OAAO,IAAI,CAACnB,WAAW,CAACc,OAAO,EAAE;MAE9D,KAAK,IAAIP,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnB,UAAU,EAAEmB,CAAC,EAAE,EAAE;QACnC,IAAIR,YAAY,CAACe,OAAO,KAAKK,OAAO,IAAI,CAACnB,WAAW,CAACc,OAAO,EAAE;QAC9DjB,eAAe,CAACwB,IAAI,IAAI;UACtB,MAAMC,IAAI,GAAGD,IAAI,CAACE,KAAK,CAAC,CAAC;UACzBD,IAAI,CAACF,GAAG,CAAC,GAAGL,UAAU,CAAC,CAAC;UACxB,OAAOO,IAAI;QACb,CAAC,CAAC;QACF;QACA,MAAM,IAAIE,OAAO,CAACC,GAAG,IAAIC,UAAU,CAACD,GAAG,EAAEpC,KAAK,CAAC,CAAC;MAClD;;MAEA;MACA,IAAIU,YAAY,CAACe,OAAO,KAAKK,OAAO,IAAI,CAACnB,WAAW,CAACc,OAAO,EAAE;MAC9DjB,eAAe,CAACwB,IAAI,IAAI;QAAA,IAAAM,SAAA;QACtB,MAAML,IAAI,GAAGD,IAAI,CAACE,KAAK,CAAC,CAAC;QACzBD,IAAI,CAACF,GAAG,CAAC,IAAAO,SAAA,GAAGzC,IAAI,CAACkC,GAAG,CAAC,cAAAO,SAAA,cAAAA,SAAA,GAAI,EAAE;QAC3B,OAAOL,IAAI;MACb,CAAC,CAAC;;MAEF;MACA,MAAM,IAAIE,OAAO,CAACC,GAAG,IAAIC,UAAU,CAACD,GAAG,EAAEpC,KAAK,CAAC,CAAC;IAClD;;IAEA;IACA,IAAIU,YAAY,CAACe,OAAO,KAAKK,OAAO,IAAInB,WAAW,CAACc,OAAO,EAAE;MAC3DjB,eAAe,CAACX,IAAI,CAACY,KAAK,CAAC,EAAE,CAAC,CAAC;IACjC;EACF,CAAC;;EAED;EACA,MAAM8B,gBAAgB,GAAGA,CAAA,KAAM;IAC7B5B,WAAW,CAACc,OAAO,GAAG,IAAI;IAC1B;IACAI,YAAY,CAAC,CAAC;EAChB,CAAC;EAED,MAAMW,gBAAgB,GAAGA,CAAA,KAAM;IAC7B7B,WAAW,CAACc,OAAO,GAAG,KAAK;IAC3B;IACAf,YAAY,CAACe,OAAO,EAAE;IACtB;IACAjB,eAAe,CAACV,aAAa,CAACW,KAAK,CAAC,EAAE,CAAC,CAAC;EAC1C,CAAC;EAED,oBACEf,OAAA;IACEQ,SAAS,EAAEE,eAAgB;IAC3BqC,YAAY,EAAEF,gBAAiB;IAC/BG,YAAY,EAAEF,gBAAiB;IAC/B,cAAY3C,IAAK;IAAA,GACbQ,KAAK;IACTsC,KAAK,EAAE;MAAEC,MAAM,EAAE,SAAS;MAAEC,OAAO,EAAE;IAAe,CAAE;IAAAC,QAAA,gBAEtDpD,OAAA;MAAMiD,KAAK,EAAE;QAAEI,QAAQ,EAAE,UAAU;QAAEC,KAAK,EAAE,CAAC;QAAEC,MAAM,EAAE,CAAC;QAAEC,OAAO,EAAE,CAAC;QAAEC,MAAM,EAAE,MAAM;QAAEC,QAAQ,EAAE,QAAQ;QAAEC,IAAI,EAAE,eAAe;QAAEC,MAAM,EAAE;MAAE,CAAE;MAAC,eAAY,MAAM;MAAAR,QAAA,EAC7JvC,YAAY,CAACgD,IAAI,CAAC,EAAE;IAAC;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAClB,CAAC,eAEPjE,OAAA;MAAM,eAAY,MAAM;MAAAoD,QAAA,EACrBvC,YAAY,CAACqD,GAAG,CAAC,CAACC,EAAE,EAAE3C,CAAC,KAAK;QAAA,IAAA4C,QAAA,EAAAC,iBAAA;QAC3B;QACA,MAAMC,OAAO,GAAGH,EAAE,OAAAC,QAAA,GAAMjE,IAAI,CAACqB,CAAC,CAAC,cAAA4C,QAAA,cAAAA,QAAA,GAAI,EAAE,CAAC;QACtC,MAAMG,WAAW,GAAGJ,EAAE,OAAAE,iBAAA,GAAMjE,aAAa,CAACoB,CAAC,CAAC,cAAA6C,iBAAA,cAAAA,iBAAA,GAAI,EAAE,CAAC;QACnD,MAAMG,GAAG,GAAGF,OAAO,GAAG9D,SAAS,GAAI+D,WAAW,GAAG9D,kBAAkB,GAAGA,kBAAmB;QACzF,oBACET,OAAA;UAAcQ,SAAS,EAAEgE,GAAI;UAAApB,QAAA,EAC1Be;QAAE,GADM3C,CAAC;UAAAsC,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAEN,CAAC;MAEX,CAAC;IAAC;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACE,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACH,CAAC;AAEX;AAACrD,EAAA,CAzHuBV,aAAa;AAAAuE,EAAA,GAAbvE,aAAa;AAAA,IAAAuE,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}