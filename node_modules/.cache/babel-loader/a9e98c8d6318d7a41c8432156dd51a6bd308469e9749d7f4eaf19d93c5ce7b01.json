{"ast":null,"code":"var _jsxFileName = \"/home/johnlemon/portfolio/src/components/extra_functions/DecryptedText.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useMemo, useRef, useState } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst DEFAULT_CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%&*()_+-=[]{};:\\'\",.<>/?';\nexport default function DecryptedText({\n  text = \"VEQQAR\",\n  encryptedText = \"V3QQ42\",\n  iterations = 10,\n  // iteraciones por letra\n  speed = 35,\n  // ms entre iteraciones\n  charset = DEFAULT_CHARSET,\n  className = 'decrypted-text',\n  encryptedClassName = 'encrypted-text',\n  parentClassName = 'decrypted-text-container',\n  ...props\n}) {\n  _s();\n  const [displayChars, setDisplayChars] = useState(() => encryptedText.split(''));\n  const animTokenRef = useRef(0); // token para cancelar animaciones\n  const hoveringRef = useRef(false);\n\n  // índices donde difieren encryptedText y text, en orden L->R\n  const diffIndices = useMemo(() => {\n    const diffs = [];\n    const maxLen = Math.max(text.length, encryptedText.length);\n    for (let i = 0; i < maxLen; i++) {\n      var _encryptedText$i, _text$i;\n      const enc = (_encryptedText$i = encryptedText[i]) !== null && _encryptedText$i !== void 0 ? _encryptedText$i : '';\n      const dec = (_text$i = text[i]) !== null && _text$i !== void 0 ? _text$i : '';\n      if (enc !== dec) diffs.push(i);\n    }\n    return diffs;\n  }, [text, encryptedText]);\n  useEffect(() => {\n    // al cambiar props sincronizamos la visual al texto encriptado\n    setDisplayChars(encryptedText.split(''));\n    animTokenRef.current++; // cancelar animaciones activas\n  }, [encryptedText, text]);\n  const randomChar = () => charset[Math.floor(Math.random() * charset.length)];\n\n  // Animación forward: por cada índice en diffIndices (L->R), hacer `iterations` cambios y luego fijar la letra final\n  const runForward = async token => {\n    for (const idx of diffIndices) {\n      // cancelar si token cambia o si ya no hay hover\n      if (animTokenRef.current !== token || !hoveringRef.current) return;\n      for (let i = 0; i < iterations; i++) {\n        if (animTokenRef.current !== token || !hoveringRef.current) return;\n        setDisplayChars(prev => {\n          const copy = prev.slice();\n          copy[idx] = randomChar();\n          return copy;\n        });\n        await new Promise(res => setTimeout(res, speed));\n      }\n      if (animTokenRef.current !== token || !hoveringRef.current) return;\n      setDisplayChars(prev => {\n        var _text$idx;\n        const copy = prev.slice();\n        copy[idx] = (_text$idx = text[idx]) !== null && _text$idx !== void 0 ? _text$idx : '';\n        return copy;\n      });\n\n      // pequeño retardo antes de la siguiente letra (opcional)\n      await new Promise(res => setTimeout(res, speed));\n    }\n\n    // si hemos terminado y no se ha cancelado, aseguramos texto final entero\n    if (animTokenRef.current === token && hoveringRef.current) {\n      setDisplayChars(text.split(''));\n    }\n  };\n\n  // Animación reverse: recorre diffIndices en orden inverso (R->L), hace `iterations` cambios y luego fija la letra encriptada\n  const runReverse = async token => {\n    const rev = [...diffIndices].reverse();\n    for (const idx of rev) {\n      // cancelar si token cambia\n      if (animTokenRef.current !== token) return;\n      for (let i = 0; i < iterations; i++) {\n        if (animTokenRef.current !== token) return;\n        setDisplayChars(prev => {\n          const copy = prev.slice();\n          copy[idx] = randomChar();\n          return copy;\n        });\n        await new Promise(res => setTimeout(res, speed));\n      }\n      if (animTokenRef.current !== token) return;\n      setDisplayChars(prev => {\n        var _encryptedText$idx;\n        const copy = prev.slice();\n        copy[idx] = (_encryptedText$idx = encryptedText[idx]) !== null && _encryptedText$idx !== void 0 ? _encryptedText$idx : '';\n        return copy;\n      });\n      await new Promise(res => setTimeout(res, speed));\n    }\n\n    // al terminar, si no se canceló, forzamos el estado encriptado completo\n    if (animTokenRef.current === token) {\n      setDisplayChars(encryptedText.split(''));\n    }\n  };\n  const handleMouseEnter = () => {\n    hoveringRef.current = true;\n    const token = ++animTokenRef.current; // cancela otras animaciones\n    runForward(token);\n  };\n  const handleMouseLeave = () => {\n    hoveringRef.current = false;\n    const token = ++animTokenRef.current; // cancela la forward actual\n    // arrancamos reverse (no comprobamos hoveringRef dentro, solo el token)\n    runReverse(token);\n  };\n  return /*#__PURE__*/_jsxDEV(\"span\", {\n    className: parentClassName,\n    onMouseEnter: handleMouseEnter,\n    onMouseLeave: handleMouseLeave,\n    \"aria-label\": text,\n    ...props,\n    style: {\n      cursor: 'pointer',\n      display: 'inline-block'\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"span\", {\n      style: {\n        position: 'absolute',\n        width: 1,\n        height: 1,\n        padding: 0,\n        margin: '-1px',\n        overflow: 'hidden',\n        clip: 'rect(0,0,0,0)',\n        border: 0\n      },\n      \"aria-hidden\": \"true\",\n      children: displayChars.join('')\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 129,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n      \"aria-hidden\": \"true\",\n      children: displayChars.map((ch, i) => {\n        var _text$i2, _encryptedText$i2;\n        const isFinal = ch === ((_text$i2 = text[i]) !== null && _text$i2 !== void 0 ? _text$i2 : '');\n        const isEncrypted = ch === ((_encryptedText$i2 = encryptedText[i]) !== null && _encryptedText$i2 !== void 0 ? _encryptedText$i2 : '');\n        const cls = isFinal ? className : isEncrypted ? encryptedClassName : encryptedClassName;\n        return /*#__PURE__*/_jsxDEV(\"span\", {\n          className: cls,\n          children: ch\n        }, i, false, {\n          fileName: _jsxFileName,\n          lineNumber: 139,\n          columnNumber: 18\n        }, this);\n      })\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 134,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 120,\n    columnNumber: 5\n  }, this);\n}\n_s(DecryptedText, \"NmOp/P1/khb/ZfzucpTAu1dIl3g=\");\n_c = DecryptedText;\nvar _c;\n$RefreshReg$(_c, \"DecryptedText\");","map":{"version":3,"names":["React","useEffect","useMemo","useRef","useState","jsxDEV","_jsxDEV","DEFAULT_CHARSET","DecryptedText","text","encryptedText","iterations","speed","charset","className","encryptedClassName","parentClassName","props","_s","displayChars","setDisplayChars","split","animTokenRef","hoveringRef","diffIndices","diffs","maxLen","Math","max","length","i","_encryptedText$i","_text$i","enc","dec","push","current","randomChar","floor","random","runForward","token","idx","prev","copy","slice","Promise","res","setTimeout","_text$idx","runReverse","rev","reverse","_encryptedText$idx","handleMouseEnter","handleMouseLeave","onMouseEnter","onMouseLeave","style","cursor","display","children","position","width","height","padding","margin","overflow","clip","border","join","fileName","_jsxFileName","lineNumber","columnNumber","map","ch","_text$i2","_encryptedText$i2","isFinal","isEncrypted","cls","_c","$RefreshReg$"],"sources":["/home/johnlemon/portfolio/src/components/extra_functions/DecryptedText.jsx"],"sourcesContent":["import React, { useEffect, useMemo, useRef, useState } from 'react';\n\nconst DEFAULT_CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%&*()_+-=[]{};:\\'\",.<>/?';\n\nexport default function DecryptedText({\n  text = \"VEQQAR\",\n  encryptedText = \"V3QQ42\",\n  iterations = 10,   // iteraciones por letra\n  speed = 35,        // ms entre iteraciones\n  charset = DEFAULT_CHARSET,\n  className = 'decrypted-text',\n  encryptedClassName = 'encrypted-text',\n  parentClassName = 'decrypted-text-container',\n  ...props\n}) {\n  const [displayChars, setDisplayChars] = useState(() => encryptedText.split(''));\n  const animTokenRef = useRef(0);   // token para cancelar animaciones\n  const hoveringRef = useRef(false);\n\n  // índices donde difieren encryptedText y text, en orden L->R\n  const diffIndices = useMemo(() => {\n    const diffs = [];\n    const maxLen = Math.max(text.length, encryptedText.length);\n    for (let i = 0; i < maxLen; i++) {\n      const enc = encryptedText[i] ?? '';\n      const dec = text[i] ?? '';\n      if (enc !== dec) diffs.push(i);\n    }\n    return diffs;\n  }, [text, encryptedText]);\n\n  useEffect(() => {\n    // al cambiar props sincronizamos la visual al texto encriptado\n    setDisplayChars(encryptedText.split(''));\n    animTokenRef.current++; // cancelar animaciones activas\n  }, [encryptedText, text]);\n\n  const randomChar = () => charset[Math.floor(Math.random() * charset.length)];\n\n  // Animación forward: por cada índice en diffIndices (L->R), hacer `iterations` cambios y luego fijar la letra final\n  const runForward = async (token) => {\n    for (const idx of diffIndices) {\n      // cancelar si token cambia o si ya no hay hover\n      if (animTokenRef.current !== token || !hoveringRef.current) return;\n\n      for (let i = 0; i < iterations; i++) {\n        if (animTokenRef.current !== token || !hoveringRef.current) return;\n        setDisplayChars(prev => {\n          const copy = prev.slice();\n          copy[idx] = randomChar();\n          return copy;\n        });\n        await new Promise(res => setTimeout(res, speed));\n      }\n\n      if (animTokenRef.current !== token || !hoveringRef.current) return;\n      setDisplayChars(prev => {\n        const copy = prev.slice();\n        copy[idx] = text[idx] ?? '';\n        return copy;\n      });\n\n      // pequeño retardo antes de la siguiente letra (opcional)\n      await new Promise(res => setTimeout(res, speed));\n    }\n\n    // si hemos terminado y no se ha cancelado, aseguramos texto final entero\n    if (animTokenRef.current === token && hoveringRef.current) {\n      setDisplayChars(text.split(''));\n    }\n  };\n\n  // Animación reverse: recorre diffIndices en orden inverso (R->L), hace `iterations` cambios y luego fija la letra encriptada\n  const runReverse = async (token) => {\n    const rev = [...diffIndices].reverse();\n    for (const idx of rev) {\n      // cancelar si token cambia\n      if (animTokenRef.current !== token) return;\n\n      for (let i = 0; i < iterations; i++) {\n        if (animTokenRef.current !== token) return;\n        setDisplayChars(prev => {\n          const copy = prev.slice();\n          copy[idx] = randomChar();\n          return copy;\n        });\n        await new Promise(res => setTimeout(res, speed));\n      }\n\n      if (animTokenRef.current !== token) return;\n      setDisplayChars(prev => {\n        const copy = prev.slice();\n        copy[idx] = encryptedText[idx] ?? '';\n        return copy;\n      });\n\n      await new Promise(res => setTimeout(res, speed));\n    }\n\n    // al terminar, si no se canceló, forzamos el estado encriptado completo\n    if (animTokenRef.current === token) {\n      setDisplayChars(encryptedText.split(''));\n    }\n  };\n\n  const handleMouseEnter = () => {\n    hoveringRef.current = true;\n    const token = ++animTokenRef.current; // cancela otras animaciones\n    runForward(token);\n  };\n\n  const handleMouseLeave = () => {\n    hoveringRef.current = false;\n    const token = ++animTokenRef.current; // cancela la forward actual\n    // arrancamos reverse (no comprobamos hoveringRef dentro, solo el token)\n    runReverse(token);\n  };\n\n  return (\n    <span\n      className={parentClassName}\n      onMouseEnter={handleMouseEnter}\n      onMouseLeave={handleMouseLeave}\n      aria-label={text}\n      {...props}\n      style={{ cursor: 'pointer', display: 'inline-block' }}\n    >\n      {/* Screen-reader text */}\n      <span style={{ position: 'absolute', width: 1, height: 1, padding: 0, margin: '-1px', overflow: 'hidden', clip: 'rect(0,0,0,0)', border: 0 }} aria-hidden=\"true\">\n        {displayChars.join('')}\n      </span>\n\n      {/* Visual */}\n      <span aria-hidden=\"true\">\n        {displayChars.map((ch, i) => {\n          const isFinal = ch === (text[i] ?? '');\n          const isEncrypted = ch === (encryptedText[i] ?? '');\n          const cls = isFinal ? className : (isEncrypted ? encryptedClassName : encryptedClassName);\n          return <span key={i} className={cls}>{ch}</span>;\n        })}\n      </span>\n    </span>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}