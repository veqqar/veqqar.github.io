{"ast":null,"code":"var _jsxFileName = \"/home/johnlemon/portfolio/src/components/extra_functions/SphereAnimation.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect } from \"react\";\nimport * as THREE from \"three\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\n\n// CircleXZAnimation — 40 circunferencias ascendiendo con zonas de color más marcadas\n// Zonas verticales (de abajo a arriba):\n//  - 0.00 - 0.25 : rojo\n//  - 0.25 - 0.50 : amarillo\n//  - 0.50 - 0.75 : naranja\n//  - 0.75 - 1.00 : azul\n// Transiciones suaves pero estrechas para que se noten claramente los cambios.\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function CircleXZAnimation() {\n  _s();\n  const mountRef = useRef(null);\n  useEffect(() => {\n    const mount = mountRef.current;\n    if (!mount) return;\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x071026);\n    const width = mount.clientWidth || window.innerWidth;\n    const height = mount.clientHeight || window.innerHeight;\n    const camera = new THREE.PerspectiveCamera(55, width / height, 0.1, 1000);\n    camera.position.set(0, 140, 260);\n    camera.lookAt(0, 50, 0);\n    const renderer = new THREE.WebGLRenderer({\n      antialias: true\n    });\n    renderer.setSize(width, height);\n    renderer.setPixelRatio(window.devicePixelRatio || 1);\n    mount.appendChild(renderer.domElement);\n    const amb = new THREE.AmbientLight(0xffffff, 0.55);\n    scene.add(amb);\n    const dir = new THREE.DirectionalLight(0xffffff, 0.4);\n    dir.position.set(50, 120, 80);\n    scene.add(dir);\n    const grid = new THREE.GridHelper(300, 30, 0x333333, 0x1a1a1a);\n    scene.add(grid);\n\n    // Parámetros\n    const R = 50; // radio de la \"esfera\"\n    const Y_MIN = 0;\n    const Y_MAX = 100;\n    const segments = 256;\n    const NUM_CIRCLES = 40; // 40 circunferencias\n\n    const circles = [];\n\n    // Colores de las zonas\n    const colorRed = new THREE.Color(0xff4b4b);\n    const colorYellow = new THREE.Color(0xffe65a);\n    const colorOrange = new THREE.Color(0xff9a3c);\n    const colorBlue = new THREE.Color(0x4aa3ff);\n    function lerp(a, b, t) {\n      return a + (b - a) * t;\n    }\n    function blendColors(c1, c2, t) {\n      return new THREE.Color(lerp(c1.r, c2.r, t), lerp(c1.g, c2.g, t), lerp(c1.b, c2.b, t));\n    }\n    function createCircle() {\n      const positions = new Float32Array((segments + 1) * 3);\n      const geometry = new THREE.BufferGeometry();\n      geometry.setAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\n      geometry.setDrawRange(0, segments + 1);\n      const material = new THREE.LineBasicMaterial({\n        color: colorOrange.clone(),\n        transparent: true,\n        opacity: 0.9\n      });\n      const line = new THREE.Line(geometry, material);\n      scene.add(line);\n      return {\n        line,\n        geometry,\n        positions,\n        material\n      };\n    }\n    function updateCircleGeometry(circle, radius) {\n      const positions = circle.positions;\n      for (let i = 0; i <= segments; i++) {\n        const t = i / segments * Math.PI * 2;\n        const x = radius * Math.cos(t);\n        const z = radius * Math.sin(t);\n        const idx = i * 3;\n        positions[idx] = x;\n        positions[idx + 1] = 0;\n        positions[idx + 2] = z;\n      }\n      circle.geometry.attributes.position.needsUpdate = true;\n    }\n    function sphereRadiusAtY(yPos) {\n      const val = R * R - (yPos - R) * (yPos - R);\n      return val > 0 ? Math.sqrt(val) : 0;\n    }\n\n    // Crear círculos y asignar offs inicial\n    const range = Y_MAX - Y_MIN;\n    for (let i = 0; i < NUM_CIRCLES; i++) {\n      const c = createCircle();\n      c.initialOffset = i / NUM_CIRCLES * range;\n      circles.push(c);\n    }\n\n    // Controles\n    const controls = new OrbitControls(camera, renderer.domElement);\n    controls.target.set(0, 50, 0);\n    controls.update();\n\n    // Tiempo absoluto para posiciones\n    const startTime = performance.now();\n    const speed = 6; // unidades Y por segundo\n\n    let rafId = null;\n\n    // calculadora de color más marcada por zonas\n    function colorByZone(yPos, radius) {\n      // Normalizamos y a 0..1 (0 = abajo, 1 = arriba)\n      const yNorm = (yPos - Y_MIN) / (Y_MAX - Y_MIN);\n      // tamaño relativo (0..1)\n      const sizeFactor = radius / R;\n\n      // Bordes de zonas y anchura de transición\n      const b1 = 0.25;\n      const b2 = 0.5;\n      const b3 = 0.75;\n      const w = 0.06; // ancho de transición para suavizar los bordes (pequeño => más nítido)\n\n      // Determinamos color base por zona con mezclas suaves en los bordes\n      let col;\n      if (yNorm <= b1 - w / 2) {\n        col = colorRed;\n      } else if (yNorm < b1 + w / 2) {\n        // transición rojo -> amarillo\n        const t = (yNorm - (b1 - w / 2)) / w;\n        col = blendColors(colorRed, colorYellow, t);\n      } else if (yNorm <= b2 - w / 2) {\n        col = colorYellow;\n      } else if (yNorm < b2 + w / 2) {\n        // transición amarillo -> naranja\n        const t = (yNorm - (b2 - w / 2)) / w;\n        col = blendColors(colorYellow, colorOrange, t);\n      } else if (yNorm <= b3 - w / 2) {\n        col = colorOrange;\n      } else if (yNorm < b3 + w / 2) {\n        // transición naranja -> azul\n        const t = (yNorm - (b3 - w / 2)) / w;\n        col = blendColors(colorOrange, colorBlue, t);\n      } else {\n        col = colorBlue;\n      }\n\n      // Ajuste de brillo según tamaño: círculos grandes (cerca de y=50) ligeramente más brillantes\n      const brightness = 0.7 + 0.35 * sizeFactor; // entre 0.7 y 1.05\n\n      return new THREE.Color(col.r * brightness, col.g * brightness, col.b * brightness);\n    }\n    function animate() {\n      const now = performance.now();\n      const elapsed = (now - startTime) / 1000; // segundos\n\n      for (let i = 0; i < NUM_CIRCLES; i++) {\n        const c = circles[i];\n        const posInRange = (c.initialOffset + elapsed * speed) % range;\n        const yPos = Y_MIN + posInRange;\n        const radius = sphereRadiusAtY(yPos);\n        updateCircleGeometry(c, radius);\n        c.line.position.y = yPos;\n        const color = colorByZone(yPos, radius);\n        c.material.color.copy(color);\n      }\n      renderer.render(scene, camera);\n      rafId = requestAnimationFrame(animate);\n    }\n    rafId = requestAnimationFrame(animate);\n    function handleResize() {\n      const w = mount.clientWidth || window.innerWidth;\n      const h = mount.clientHeight || window.innerHeight;\n      camera.aspect = w / h;\n      camera.updateProjectionMatrix();\n      renderer.setSize(w, h);\n    }\n    window.addEventListener(\"resize\", handleResize);\n\n    // Limpieza al desmontar\n    return () => {\n      window.removeEventListener(\"resize\", handleResize);\n      if (rafId) cancelAnimationFrame(rafId);\n      circles.forEach(c => {\n        scene.remove(c.line);\n        c.geometry.dispose();\n        c.material.dispose();\n      });\n      controls.dispose();\n      renderer.dispose();\n      if (renderer.domElement && mount.contains(renderer.domElement)) {\n        mount.removeChild(renderer.domElement);\n      }\n    };\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: mountRef,\n    style: {\n      width: \"100vw\",\n      height: \"100vh\",\n      position: \"relative\"\n    },\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: \"absolute\",\n        left: 12,\n        top: 12,\n        padding: \"6px 10px\",\n        background: \"rgba(0,0,0,0.35)\",\n        color: \"#e6fff0\",\n        borderRadius: 8,\n        fontSize: 13\n      },\n      children: \"40 circunferencias ascendiendo \\u2014 zonas de color m\\xE1s marcadas (rojo \\u2192 amarillo \\u2192 naranja \\u2192 azul)\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 221,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 220,\n    columnNumber: 5\n  }, this);\n}\n_s(CircleXZAnimation, \"V9/qkEdV8GfsDZk7lMTA1T8g5Ps=\");\n_c = CircleXZAnimation;\nvar _c;\n$RefreshReg$(_c, \"CircleXZAnimation\");","map":{"version":3,"names":["React","useRef","useEffect","THREE","OrbitControls","jsxDEV","_jsxDEV","CircleXZAnimation","_s","mountRef","mount","current","scene","Scene","background","Color","width","clientWidth","window","innerWidth","height","clientHeight","innerHeight","camera","PerspectiveCamera","position","set","lookAt","renderer","WebGLRenderer","antialias","setSize","setPixelRatio","devicePixelRatio","appendChild","domElement","amb","AmbientLight","add","dir","DirectionalLight","grid","GridHelper","R","Y_MIN","Y_MAX","segments","NUM_CIRCLES","circles","colorRed","colorYellow","colorOrange","colorBlue","lerp","a","b","t","blendColors","c1","c2","r","g","createCircle","positions","Float32Array","geometry","BufferGeometry","setAttribute","BufferAttribute","setDrawRange","material","LineBasicMaterial","color","clone","transparent","opacity","line","Line","updateCircleGeometry","circle","radius","i","Math","PI","x","cos","z","sin","idx","attributes","needsUpdate","sphereRadiusAtY","yPos","val","sqrt","range","c","initialOffset","push","controls","target","update","startTime","performance","now","speed","rafId","colorByZone","yNorm","sizeFactor","b1","b2","b3","w","col","brightness","animate","elapsed","posInRange","y","copy","render","requestAnimationFrame","handleResize","h","aspect","updateProjectionMatrix","addEventListener","removeEventListener","cancelAnimationFrame","forEach","remove","dispose","contains","removeChild","ref","style","children","left","top","padding","borderRadius","fontSize","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/johnlemon/portfolio/src/components/extra_functions/SphereAnimation.jsx"],"sourcesContent":["import React, { useRef, useEffect } from \"react\";\nimport * as THREE from \"three\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\n\n// CircleXZAnimation — 40 circunferencias ascendiendo con zonas de color más marcadas\n// Zonas verticales (de abajo a arriba):\n//  - 0.00 - 0.25 : rojo\n//  - 0.25 - 0.50 : amarillo\n//  - 0.50 - 0.75 : naranja\n//  - 0.75 - 1.00 : azul\n// Transiciones suaves pero estrechas para que se noten claramente los cambios.\n\nexport default function CircleXZAnimation() {\n  const mountRef = useRef(null);\n\n  useEffect(() => {\n    const mount = mountRef.current;\n    if (!mount) return;\n\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x071026);\n\n    const width = mount.clientWidth || window.innerWidth;\n    const height = mount.clientHeight || window.innerHeight;\n\n    const camera = new THREE.PerspectiveCamera(55, width / height, 0.1, 1000);\n    camera.position.set(0, 140, 260);\n    camera.lookAt(0, 50, 0);\n\n    const renderer = new THREE.WebGLRenderer({ antialias: true });\n    renderer.setSize(width, height);\n    renderer.setPixelRatio(window.devicePixelRatio || 1);\n    mount.appendChild(renderer.domElement);\n\n    const amb = new THREE.AmbientLight(0xffffff, 0.55);\n    scene.add(amb);\n    const dir = new THREE.DirectionalLight(0xffffff, 0.4);\n    dir.position.set(50, 120, 80);\n    scene.add(dir);\n\n    const grid = new THREE.GridHelper(300, 30, 0x333333, 0x1a1a1a);\n    scene.add(grid);\n\n    // Parámetros\n    const R = 50; // radio de la \"esfera\"\n    const Y_MIN = 0;\n    const Y_MAX = 100;\n    const segments = 256;\n    const NUM_CIRCLES = 40; // 40 circunferencias\n\n    const circles = [];\n\n    // Colores de las zonas\n    const colorRed = new THREE.Color(0xff4b4b);\n    const colorYellow = new THREE.Color(0xffe65a);\n    const colorOrange = new THREE.Color(0xff9a3c);\n    const colorBlue = new THREE.Color(0x4aa3ff);\n\n    function lerp(a, b, t) {\n      return a + (b - a) * t;\n    }\n\n    function blendColors(c1, c2, t) {\n      return new THREE.Color(lerp(c1.r, c2.r, t), lerp(c1.g, c2.g, t), lerp(c1.b, c2.b, t));\n    }\n\n    function createCircle() {\n      const positions = new Float32Array((segments + 1) * 3);\n      const geometry = new THREE.BufferGeometry();\n      geometry.setAttribute(\"position\", new THREE.BufferAttribute(positions, 3));\n      geometry.setDrawRange(0, segments + 1);\n\n      const material = new THREE.LineBasicMaterial({\n        color: colorOrange.clone(),\n        transparent: true,\n        opacity: 0.9,\n      });\n\n      const line = new THREE.Line(geometry, material);\n      scene.add(line);\n\n      return { line, geometry, positions, material };\n    }\n\n    function updateCircleGeometry(circle, radius) {\n      const positions = circle.positions;\n      for (let i = 0; i <= segments; i++) {\n        const t = (i / segments) * Math.PI * 2;\n        const x = radius * Math.cos(t);\n        const z = radius * Math.sin(t);\n        const idx = i * 3;\n        positions[idx] = x;\n        positions[idx + 1] = 0;\n        positions[idx + 2] = z;\n      }\n      circle.geometry.attributes.position.needsUpdate = true;\n    }\n\n    function sphereRadiusAtY(yPos) {\n      const val = R * R - (yPos - R) * (yPos - R);\n      return val > 0 ? Math.sqrt(val) : 0;\n    }\n\n    // Crear círculos y asignar offs inicial\n    const range = Y_MAX - Y_MIN;\n    for (let i = 0; i < NUM_CIRCLES; i++) {\n      const c = createCircle();\n      c.initialOffset = (i / NUM_CIRCLES) * range;\n      circles.push(c);\n    }\n\n    // Controles\n    const controls = new OrbitControls(camera, renderer.domElement);\n    controls.target.set(0, 50, 0);\n    controls.update();\n\n    // Tiempo absoluto para posiciones\n    const startTime = performance.now();\n    const speed = 6; // unidades Y por segundo\n\n    let rafId = null;\n\n    // calculadora de color más marcada por zonas\n    function colorByZone(yPos, radius) {\n      // Normalizamos y a 0..1 (0 = abajo, 1 = arriba)\n      const yNorm = (yPos - Y_MIN) / (Y_MAX - Y_MIN);\n      // tamaño relativo (0..1)\n      const sizeFactor = radius / R;\n\n      // Bordes de zonas y anchura de transición\n      const b1 = 0.25;\n      const b2 = 0.5;\n      const b3 = 0.75;\n      const w = 0.06; // ancho de transición para suavizar los bordes (pequeño => más nítido)\n\n      // Determinamos color base por zona con mezclas suaves en los bordes\n      let col;\n\n      if (yNorm <= b1 - w / 2) {\n        col = colorRed;\n      } else if (yNorm < b1 + w / 2) {\n        // transición rojo -> amarillo\n        const t = (yNorm - (b1 - w / 2)) / w;\n        col = blendColors(colorRed, colorYellow, t);\n      } else if (yNorm <= b2 - w / 2) {\n        col = colorYellow;\n      } else if (yNorm < b2 + w / 2) {\n        // transición amarillo -> naranja\n        const t = (yNorm - (b2 - w / 2)) / w;\n        col = blendColors(colorYellow, colorOrange, t);\n      } else if (yNorm <= b3 - w / 2) {\n        col = colorOrange;\n      } else if (yNorm < b3 + w / 2) {\n        // transición naranja -> azul\n        const t = (yNorm - (b3 - w / 2)) / w;\n        col = blendColors(colorOrange, colorBlue, t);\n      } else {\n        col = colorBlue;\n      }\n\n      // Ajuste de brillo según tamaño: círculos grandes (cerca de y=50) ligeramente más brillantes\n      const brightness = 0.7 + 0.35 * sizeFactor; // entre 0.7 y 1.05\n\n      return new THREE.Color(col.r * brightness, col.g * brightness, col.b * brightness);\n    }\n\n    function animate() {\n      const now = performance.now();\n      const elapsed = (now - startTime) / 1000; // segundos\n\n      for (let i = 0; i < NUM_CIRCLES; i++) {\n        const c = circles[i];\n        const posInRange = (c.initialOffset + elapsed * speed) % range;\n        const yPos = Y_MIN + posInRange;\n\n        const radius = sphereRadiusAtY(yPos);\n        updateCircleGeometry(c, radius);\n        c.line.position.y = yPos;\n\n        const color = colorByZone(yPos, radius);\n        c.material.color.copy(color);\n      }\n\n      renderer.render(scene, camera);\n      rafId = requestAnimationFrame(animate);\n    }\n\n    rafId = requestAnimationFrame(animate);\n\n    function handleResize() {\n      const w = mount.clientWidth || window.innerWidth;\n      const h = mount.clientHeight || window.innerHeight;\n      camera.aspect = w / h;\n      camera.updateProjectionMatrix();\n      renderer.setSize(w, h);\n    }\n\n    window.addEventListener(\"resize\", handleResize);\n\n    // Limpieza al desmontar\n    return () => {\n      window.removeEventListener(\"resize\", handleResize);\n      if (rafId) cancelAnimationFrame(rafId);\n\n      circles.forEach((c) => {\n        scene.remove(c.line);\n        c.geometry.dispose();\n        c.material.dispose();\n      });\n\n      controls.dispose();\n      renderer.dispose();\n      if (renderer.domElement && mount.contains(renderer.domElement)) {\n        mount.removeChild(renderer.domElement);\n      }\n    };\n  }, []);\n\n  return (\n    <div ref={mountRef} style={{ width: \"100vw\", height: \"100vh\", position: \"relative\" }}>\n      <div style={{ position: \"absolute\", left: 12, top: 12, padding: \"6px 10px\", background: \"rgba(0,0,0,0.35)\", color: \"#e6fff0\", borderRadius: 8, fontSize: 13 }}>\n        40 circunferencias ascendiendo — zonas de color más marcadas (rojo → amarillo → naranja → azul)\n      </div>\n    </div>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}